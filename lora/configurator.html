<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LORA Scenario Configurator</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: #f4f7fa;
      margin: 0;
      color: #333;
    }
    .hidden {
      display: none !important;
    }
    .file-upload {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      background-color: #ffffff;
      transition: all 0.2s ease-in-out;
      margin: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .file-upload.drag-over {
      border-color: #007bff;
      background-color: #f0f8ff;
    }
    .file-upload h3 {
      margin-top: 0;
      color: #333;
    }
    .file-upload p {
      color: #666;
    }
    #upload-error-message {
        color: #d9534f;
        font-weight: bold;
    }
    .file-input {
      margin-top: 20px;
    }
    .file-input input[type="file"] {
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
    }
    .file-input label {
      display: inline-block;
      padding: 10px 20px;
      font-size: 16px;
      font-weight: bold;
      color: #fff;
      background-color: #007bff;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .file-input label:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <div class="rtt-container">
    <!-- MODIFICATION: Header structure updated to match new design system -->
    <header class="rtt-sticky-header">
      <div class="rtt-brand-bar">
        <!-- NOTE: The logo path is based on the provided file. Ensure 'images/HealthNZ_logo_v2.svg' exists in your project structure. -->
        <img src="../images/HealthNZ_logo_v2.svg" alt="Health NZ Logo" class="rtt-app-logo">
        <div class="rtt-header-divider"></div>
        <h1 class="rtt-title">LORA Scenario Configurator</h1>
        <div class="rtt-flex-spacer"></div>

        <div id="header-controls-wrapper" class="hidden">
          <div class="rtt-header-controls">
            <div class="scenario-controls" id="scenario-toggle">
              <input type="radio" id="source-baseline" name="data-source" value="baseline" checked>
              <label for="source-baseline">Baseline</label>
              <input type="radio" id="source-scenario" name="data-source" value="scenario">
              <label for="source-scenario">Scenario</label>
              <span class="scenario-switch-bg" aria-hidden="true"></span>
            </div>
            <button id="export-button" class="rtt-download-btn">
              <!-- Spinner will be added here by JS -->
              Export CSV
            </button>
          </div>
        </div>
      </div>
    </header>

    <main id="main-content" class="rtt-main-content">
      <div id="file-upload-area" class="file-upload hidden">
        <h3>Load Configuration Data</h3>
        <p id="upload-error-message" class="hidden">Could not load local file. Please upload your CSV to begin.</p>
        <p>Drag & drop your CSV file here, or click to select.</p>
        <div class="file-input">
          <input type="file" id="csv-file-input" accept=".csv" />
          <label for="csv-file-input">Choose File</label>
        </div>
      </div>

      <div id="scenario-name-card" class="modality-container hidden">
        <div class="modality-header">
          <h2>Scenario Name</h2>
        </div>
        <div class="scenario-name-content">
          <label for="scenario-name-input">Enter a name for your scenario:</label>
          <input type="text" id="scenario-name-input" placeholder="e.g., High Growth Projection">
        </div>
      </div>
      
      <div id="app">
        <div class="app-loading-message">Loading Configuration...</div>
      </div>
    </main>
    
    <div id="status-message" class="status-message"></div>
  </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script>
    const staticFields = ["non_demographic_growth", "routine_machine_hours", "share_of_scans_during_day", "ooh_machines", "ras_per_routine_machine_hour", "mit_shift_length", "mit_weeks_lost", "session_length_hours", "clinical_reporting_sessions_per_rad", "rad_weeks_lost"];
    const staticFieldLabels = { "non_demographic_growth": "Non-Demographic Growth", "routine_machine_hours": "Routine Machine Hours", "share_of_scans_during_day": "Share of Scans During Day", "ooh_machines": "Out-of-Hours (OOH) Machines", "ras_per_routine_machine_hour": "RAs per Routine Machine Hour", "mit_shift_length": "MIT Shift Length", "mit_weeks_lost": "MIT Weeks Lost", "session_length_hours": "Session Length (Hours)", "clinical_reporting_sessions_per_rad": "Clinical Reporting Sessions per Rad", "rad_weeks_lost": "Radiologist Weeks Lost" };
    const staticFieldDescriptions = { "non_demographic_growth": "Non-demographic growth is a % change to apply over and above demographic growth (which comes from population projections). This varies by Modality.", "routine_machine_hours": "Routine machine hours provides the number of hours one machine of that modality would be expected to run in a normal working week.", "share_of_scans_during_day": "This is the % of events that occurred during routine hours which sets the level of activity to meet in hours.", "ooh_machines": "This is the number of machines each archetype is expected to run out of hours (OOH).", "ras_per_routine_machine_hour": "Radiology Assistants (RAs) support efficient delivery of CT and MR modalities. This ratio provides the number of RAs needed per routine machine hour.", "mit_shift_length": "MITs run the modalities and so to identify their FTE requirements we need to set the shift length they will work. This is strictly 4 hours.", "mit_weeks_lost": "This is a factor to account for cover given the need for MITs to take leave.", "session_length_hours": "This is the length of a session that a radiologist reports on events, this tends to be 4 hours.", "clinical_reporting_sessions_per_rad": "This provides the number of reporting sessions that each radiologist does per week - this varies by archetype as larger facilities have a broader set of responsibilities for radiologists.", "rad_weeks_lost": "This is a factor to account for cover given the need for radiologists to take leave." };

    const projectionMetrics = ["ip_volume_step", "op_volume_step", "scan_rate", "report_rate", "mits_per_routine_machine_hour", "mits_per_ooh_machine_hour"];
    const projectionMetricLabels = { "ip_volume_step": "Inpatient Volume Step", "op_volume_step": "Outpatient Volume Step", "scan_rate": "Scan Rate", "report_rate": "Report Rate", "mits_per_routine_machine_hour": "MITs per Routine Machine Hour", "mits_per_ooh_machine_hour": "MITs per OOH Machine Hour" };
    const projectionMetricDescriptions = { "ip_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "op_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "scan_rate": "These financial-year-based 10 fields provide the number of minutes required for modality to be scanning per event, which may change over time as technologies change. These vary by modality and archetype.", "report_rate": "These financial-year-based 10 fields provide the number of minutes required for a radiologist to report on an event, which may change over time as technologies change. These vary by modality and archetype", "mits_per_routine_machine_hour": "These financial-year-based 10 fields provide the number of MITs required in-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype.", "mits_per_ooh_machine_hour": "These financial-year-based 10 fields provide the number of MITs required out-of-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype." };
    
    const years = Array.from({ length: 11 }, (_, i) => `y${i}`);
    
    // MODIFICATION: Default base year start. This will be updated by the CSV.
    let baseYearStart = new Date().getFullYear(); 
    
    const archetypeSortOrder = { "X Small": 1, "Small": 2, "Medium": 3, "Large": 4, "X Large": 5, };
    const staticFieldSliderConfig = { non_demographic_growth: { min: -0.05, max: 0.1, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s) / 100 }, routine_machine_hours: { min: 40, max: 84, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, share_of_scans_during_day: { min: 90, max: 100, step: 0.1, format: v => `${(parseFloat(v) * 100).toFixed(0)}%`, parse: s => parseFloat(s) / 100 }, ooh_machines: { min: 0, max: 4, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, ras_per_routine_machine_hour: { min: 0, max: 2, step: 0.1, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, mit_shift_length: { min: 4, max: 6, step: 1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, mit_weeks_lost: { min: 6, max: 8, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, session_length_hours: { min: 4, max: 5, step: 0.5, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, clinical_reporting_sessions_per_rad: { min: 2, max: 10, step: 0.5, format: v => Math.round(v), parse: s => parseFloat(s) }, rad_weeks_lost: { min: 10, max: 14, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, };

    const app = document.getElementById("app");
    const headerControlsWrapper = document.getElementById("header-controls-wrapper");
    const scenarioToggle = document.getElementById("scenario-toggle");
    const exportButton = document.getElementById("export-button");
    const statusMessage = document.getElementById("status-message");
    const fileUploadArea = document.getElementById("file-upload-area");
    const fileInput = document.getElementById("csv-file-input");
    const scenarioNameCard = document.getElementById("scenario-name-card");
    const scenarioNameInput = document.getElementById("scenario-name-input");

    let baselineData = [], scenarioData = [], activePanelIds = new Set(), messageTimeout;
    let scenarioName = "";

    document.addEventListener('DOMContentLoaded', loadAndInitializeData);
    fileInput.addEventListener('change', (e) => loadCSVFile(e.target.files[0]));
    fileUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); fileUploadArea.classList.add('drag-over'); });
    fileUploadArea.addEventListener('dragleave', () => fileUploadArea.classList.remove('drag-over'));
    fileUploadArea.addEventListener('drop', (e) => { e.preventDefault(); fileUploadArea.classList.remove('drag-over'); loadCSVFile(e.dataTransfer.files[0]); });
    scenarioNameInput.addEventListener('input', (e) => {
        scenarioName = e.target.value;
    });

    async function loadAndInitializeData() {
      try {
        const response = await fetch('input_configuration_snowflake_baseline_2023_2024.csv');
        if (!response.ok) {
           const fallbackResponse = await fetch('baseline.csv');
           if (!fallbackResponse.ok) throw new Error(`HTTP error! status: ${fallbackResponse.status}`);
           const csvText = await fallbackResponse.text();
           processCSV(csvText, "Successfully loaded baseline data.");
           return;
        }
        const csvText = await response.text();
        processCSV(csvText, "Successfully loaded baseline data.");
      } catch (error) {
        console.error("Could not auto-load CSV:", error);
        const appLoadingMessage = document.querySelector('.app-loading-message');
        if (appLoadingMessage) {
            appLoadingMessage.classList.add('hidden');
        }
        fileUploadArea.classList.remove('hidden');
        document.getElementById('upload-error-message').classList.remove('hidden');
      }
    }
    
    function loadCSVFile(file) {
      if (file && (file.type === "text/csv" || file.name.endsWith('.csv'))) {
        const reader = new FileReader();
        reader.onload = function(event) {
          processCSV(event.target.result, "Successfully loaded uploaded file.");
          document.getElementById('upload-error-message').classList.add('hidden');
        };
        reader.onerror = function() {
            showMessage("Error reading the file.", "error");
        };
        reader.readAsText(file);
      } else {
        showMessage("Please select a valid .csv file.", "error");
      }
    }

    function processCSV(csvText, successMessage) {
      Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: true,
        complete: function(results) {
          if (results.errors.length) {
            console.error("CSV Parsing Errors:", results.errors);
            showMessage("Error parsing CSV file. Check for jagged rows or header issues.", "error");
            fileUploadArea.classList.remove('hidden');
            return;
          }
          
          const processedData = results.data.map(flatRow => {
              const newRow = { ...flatRow };
              projectionMetrics.forEach(metric => {
                  newRow[metric] = {}; 
                  years.forEach(yearKey => {
                      const flatHeaderKey = `${metric}_${yearKey}`; 
                      if (flatRow.hasOwnProperty(flatHeaderKey)) {
                          newRow[metric][yearKey] = flatRow[flatHeaderKey];
                          delete newRow[flatHeaderKey];
                      }
                  });
              });
              if (!newRow.id) {
                  newRow.id = `${newRow.modality}-${newRow.archetype}`.replace(/\s+/g, '-').toLowerCase();
              }
              return newRow;
          });

          // MODIFICATION: Parse the financial year format from the CSV.
          if (processedData.length > 0 && processedData[0].baseyear) {
              const baseYearString = String(processedData[0].baseyear).trim();
              // Regex to match "YYYY/YY" or a single "YYYY"
              const match = baseYearString.match(/^(\d{4})(?:\/\d{2})?$/); 
              if (match && match[1]) {
                  const parsedStartYear = parseInt(match[1], 10);
                  if (!isNaN(parsedStartYear)) {
                      baseYearStart = parsedStartYear;
                      console.log(`Base financial year start set to ${baseYearStart} from CSV value "${baseYearString}".`);
                  }
              } else {
                  console.warn(`Could not parse baseyear format: "${baseYearString}". Using default.`);
              }
          }

          baselineData = JSON.parse(JSON.stringify(processedData));
          scenarioData = JSON.parse(JSON.stringify(processedData));
          
          activePanelIds.clear();
          scenarioName = "";

          fileUploadArea.classList.add('hidden');
          headerControlsWrapper.classList.remove('hidden');
          
          renderUI(baselineData, false); 
          showMessage(successMessage, "success");
        },
        error: function(error) {
            console.error("PapaParse Error:", error);
            showMessage("A critical error occurred while parsing the file.", "error");
            fileUploadArea.classList.remove('hidden');
        }
      });
    }

    // MODIFICATION: New helper function to format financial year labels
    function formatFinancialYear(startYear) {
        const endYear = (startYear + 1) % 100;
        return `${startYear}/${String(endYear).padStart(2, '0')}`;
    }

    function showMessage(message, type) {
      clearTimeout(messageTimeout);
      const p = document.createElement('p');
      p.className = type;
      p.textContent = message;
      statusMessage.innerHTML = '';
      statusMessage.appendChild(p);
      messageTimeout = setTimeout(() => {
        statusMessage.innerHTML = '';
      }, 2000);
    }
    
    scenarioToggle.addEventListener('change', (e) => {
      activePanelIds.clear();
      document.querySelectorAll('.archetype-content-panel.active').forEach(panel => activePanelIds.add(panel.id));
      const isBaseline = e.target.value === 'baseline';
      renderUI(isBaseline ? baselineData : scenarioData, !isBaseline);
    });

    function updateChangeState(rowId) {
        const rowToUpdate = scenarioData.find(row => String(row.id) === String(rowId));
        const baselineRow = baselineData.find(row => String(row.id) === String(rowId));
        if (!rowToUpdate || !baselineRow) return;

        let hasAnyChanges = staticFields.some(key =>
            Math.abs(parseFloat(rowToUpdate[key]) - parseFloat(baselineRow[key])) > 1e-9
        ) || projectionMetrics.some(metric =>
            years.some(yearKey => baselineRow[metric]?.[yearKey] !== rowToUpdate[metric]?.[yearKey])
        );
        
        const button = document.querySelector(`.archetype-button[data-id="${rowId}"]`);
        if (button) {
            button.classList.toggle('has-changes', hasAnyChanges);
        }

        const panel = document.querySelector(`#panel-${rowId}`);
        if (panel) {
            panel.querySelectorAll('[data-field]').forEach(input => {
                const fieldKey = input.dataset.field;
                if (fieldKey.includes('.')) { // Yearly projection
                    const [metric, year] = fieldKey.split('.');
                    const isFieldChanged = baselineRow[metric]?.[year] !== rowToUpdate[metric]?.[year];
                    input.classList.toggle('changed', isFieldChanged);
                } else { // Static slider field
                    const isFieldChanged = Math.abs(parseFloat(rowToUpdate[fieldKey]) - parseFloat(baselineRow[fieldKey])) > 1e-9;
                    const fieldContainer = input.closest('.slider-field');
                    if (fieldContainer) {
                        fieldContainer.classList.toggle('changed', isFieldChanged);
                    }
                }
            });
        }
    }

    function handleSliderInput(e) {
      const slider = e.target;
      if (slider.type !== 'range') return;

      const { id: rowId, field: fieldKey } = slider.dataset;
      const newValue = parseFloat(slider.value);
      const rowToUpdate = scenarioData.find(row => String(row.id) === String(rowId));
      const config = staticFieldSliderConfig[fieldKey];
      
      if (!rowToUpdate || !config) return;

      const display = slider.closest('.slider-field').querySelector('.slider-value-display');
      display.value = config.format(newValue);
      
      rowToUpdate[fieldKey] = newValue;
      updateChangeState(rowId);
    }
    
    function handleTextChange(e) {
        const textInput = e.target;
        const { id: rowId, field: fieldKey } = textInput.dataset;
        if (!rowId || !fieldKey) return;

        const rowToUpdate = scenarioData.find(row => String(row.id) === String(rowId));
        if (!rowToUpdate) return;
        
        if (textInput.classList.contains('slider-value-display')) {
            const config = staticFieldSliderConfig[fieldKey];
            if (!config) return;

            let parsedValue = config.parse(textInput.value);
            if (isNaN(parsedValue)) {
                textInput.value = config.format(rowToUpdate[fieldKey]);
                return;
            }

            const clampedValue = Math.max(config.min, Math.min(config.max, parsedValue));
            const slider = textInput.closest('.slider-field').querySelector('input[type=range]');
            slider.value = clampedValue;
            rowToUpdate[fieldKey] = clampedValue;
            textInput.value = config.format(clampedValue);
        } 
        else if (textInput.classList.contains('projection-input')) {
            const [metric, yearKey] = fieldKey.split('.');
            const originalValue = rowToUpdate[metric]?.[yearKey];
            const numericValue = parseFloat(textInput.value);
            
            if (isNaN(numericValue)) {
                textInput.value = typeof originalValue === 'number' ? originalValue.toFixed(2) : originalValue || 'N/A';
                return;
            }
            
            rowToUpdate[metric][yearKey] = numericValue;
            textInput.value = numericValue.toFixed(2);
        }

        updateChangeState(rowId);
    }
    
    app.addEventListener('input', handleSliderInput);
    app.addEventListener('touchmove', handleSliderInput);
    app.addEventListener('change', handleTextChange);

    app.addEventListener('click', (e) => {
        if (e.target.classList.contains('archetype-button')) {
            const button = e.target;
            const targetPanelId = button.dataset.target;
            const panel = document.querySelector(targetPanelId);
            if (!panel) return;

            if (panel.classList.contains('active')) {
                panel.classList.remove('active');
                button.classList.remove('active');
            } else {
                panel.classList.add('active');
                button.classList.add('active');
            }
        }

        if (e.target.classList.contains('info-icon')) {
            const icon = e.target;
            const tooltip = icon.nextElementSibling;
            
            document.querySelectorAll('.info-tooltip.visible').forEach(visibleTooltip => {
                if (visibleTooltip !== tooltip) {
                    visibleTooltip.classList.remove('visible');
                }
            });
            if (tooltip && tooltip.classList.contains('info-tooltip')) {
                tooltip.classList.toggle('visible');
            }
        }
    });

    exportButton.addEventListener('click', () => {
        const spinner = document.createElement('span');
        spinner.className = 'loading-spinner';
        exportButton.prepend(spinner);
        exportButton.disabled = true;

        setTimeout(() => { 
            const dataToExport = JSON.parse(JSON.stringify(scenarioData));
            
            const flatData = dataToExport.map(row => {
                const newFlatRow = { ...row };
                projectionMetrics.forEach(metric => {
                    if (newFlatRow[metric]) {
                        years.forEach(yearKey => {
                            const flatHeaderKey = `${metric}_${yearKey}`;
                            newFlatRow[flatHeaderKey] = newFlatRow[metric][yearKey];
                        });
                        delete newFlatRow[metric];
                    }
                });
                return newFlatRow;
            });

            const csv = Papa.unparse(flatData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            const filename = scenarioName.trim().replace(/\s+/g, '_') || 'scenario_export';
            link.setAttribute("download", `${filename}_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            exportButton.removeChild(spinner);
            exportButton.disabled = false;
            showMessage("CSV exported successfully!", "success");
        }, 500);
    });

    function renderUI(dataToRender, isEditable) {
      app.innerHTML = "";
      if (isEditable) {
        scenarioNameCard.classList.remove('hidden');
        scenarioNameInput.value = scenarioName;
      } else {
        scenarioNameCard.classList.add('hidden');
      }

      const grouped = dataToRender.reduce((acc, row) => {
        const { modality, archetype } = row;
        if (!acc[modality]) acc[modality] = {};
        if (!acc[modality][archetype]) acc[modality][archetype] = [];
        acc[modality][archetype].push(row);
        return acc;
      }, {});

      for (const modality of Object.keys(grouped).sort()) {
        const modalityContainer = document.createElement('div');
        modalityContainer.className = 'modality-container';
        
        const modalityHeader = document.createElement('div');
        modalityHeader.className = 'modality-header';
        const modalityTitle = document.createElement('h2');
        modalityTitle.textContent = modality;
        const archetypeButtonsDiv = document.createElement('div');
        archetypeButtonsDiv.className = 'archetype-buttons';
        modalityHeader.appendChild(modalityTitle);
        modalityHeader.appendChild(archetypeButtonsDiv);
        modalityContainer.appendChild(modalityHeader);

        for (const archetype of Object.keys(grouped[modality]).sort((a, b) => (archetypeSortOrder[a] || 99) - (archetypeSortOrder[b] || 99))) {
          const row = grouped[modality][archetype][0];
          const panelId = `panel-${row.id}`;

          const button = document.createElement('button');
          button.className = 'archetype-button';
          button.textContent = archetype;
          button.dataset.target = `#${panelId}`;
          button.dataset.id = row.id;
          
          const baselineRow = baselineData.find(br => String(br.id) === String(row.id));
          if (isEditable && baselineRow) {
            const hasAnyChanges = staticFields.some(key =>
              row[key] != null && baselineRow[key] != null &&
              Math.abs(parseFloat(row[key]) - parseFloat(baselineRow[key])) > 1e-9
            ) || projectionMetrics.some(metric =>
              years.some(yearKey => row[metric]?.[yearKey] !== baselineRow[metric]?.[yearKey])
            );
            if (hasAnyChanges) { button.classList.add('has-changes'); }
          }
          archetypeButtonsDiv.appendChild(button);

          const panel = document.createElement('div');
          panel.className = 'archetype-content-panel';
          panel.id = panelId;
          
          const staticHeader = document.createElement("h3");
          staticHeader.textContent = 'Static Fields';
          panel.appendChild(staticHeader);
          const staticGrid = document.createElement("div");
          staticGrid.className = "static-fields-grid";
          
          staticFields.forEach(field => {
            const config = staticFieldSliderConfig[field];
            if (!config) return;

            const fieldDiv = document.createElement("div");
            fieldDiv.className = "slider-field";
            
            const labelWrapper = document.createElement('div');
            labelWrapper.className = 'label-wrapper';
            const label = document.createElement("label");
            label.textContent = staticFieldLabels[field] || field;
            labelWrapper.appendChild(label);
            
            const infoContainer = document.createElement('div');
            infoContainer.className = 'info-container';
            const infoIcon = document.createElement('span');
            infoIcon.className = 'info-icon';
            infoIcon.textContent = '?';
            const tooltip = document.createElement('div');
            tooltip.className = 'info-tooltip';
            tooltip.textContent = staticFieldDescriptions[field] || 'No description available.';
            infoContainer.appendChild(infoIcon);
            infoContainer.appendChild(tooltip);
            labelWrapper.appendChild(infoContainer);

            fieldDiv.appendChild(labelWrapper);

            const controlsWrapper = document.createElement('div');
            controlsWrapper.className = 'slider-control-wrapper';
            const valueDisplay = document.createElement('input');
            valueDisplay.type = 'text';
            valueDisplay.className = 'slider-value-display';
            valueDisplay.value = config.format(row[field] != null ? row[field] : config.min);
            valueDisplay.dataset.id = row.id;
            valueDisplay.dataset.field = field;

            if (isEditable) {
              const slider = document.createElement("input");
              slider.type = "range";
              slider.min = config.min; slider.max = config.max; slider.step = config.step;
              slider.value = row[field] != null ? row[field] : config.min;
              slider.dataset.id = row.id; slider.dataset.field = field;
              controlsWrapper.appendChild(slider);
              if (baselineRow && Math.abs(parseFloat(row[field]) - parseFloat(baselineRow[field])) > 1e-9) {
                fieldDiv.classList.add('changed');
              }
            } else {
                valueDisplay.readOnly = true;
            }
            
            controlsWrapper.appendChild(valueDisplay);
            fieldDiv.appendChild(controlsWrapper);
            staticGrid.appendChild(fieldDiv);
          });
          panel.appendChild(staticGrid);

          const projHeader = document.createElement("h3");
          projHeader.textContent = 'Yearly Projections';
          panel.appendChild(projHeader);
          const projectionsGrid = document.createElement("div");
          projectionsGrid.className = "projections-grid";
          projectionMetrics.forEach(metric => {
              const card = document.createElement('div');
              card.className = 'projection-metric-card';
              
              const titleWrapper = document.createElement('div');
              titleWrapper.className = 'title-wrapper';
              const cardTitle = document.createElement('h4');
              cardTitle.textContent = projectionMetricLabels[metric] || metric;
              titleWrapper.appendChild(cardTitle);

              const infoContainer = document.createElement('div');
              infoContainer.className = 'info-container';
              const infoIcon = document.createElement('span');
              infoIcon.className = 'info-icon';
              infoIcon.textContent = '?';
              const tooltip = document.createElement('div');
              tooltip.className = 'info-tooltip';
              tooltip.textContent = projectionMetricDescriptions[metric] || 'No description available.';
              infoContainer.appendChild(infoIcon);
              infoContainer.appendChild(tooltip);
              titleWrapper.appendChild(infoContainer);
              
              card.appendChild(titleWrapper);

              const yearInputsContainer = document.createElement('div');
              yearInputsContainer.className = 'year-inputs-container';
              
              years.forEach((yearKey, index) => {
                  const item = document.createElement('div');
                  item.className = 'year-input-item';
                  const label = document.createElement('label');
                  // MODIFICATION: Use the financial year formatter for the label
                  label.textContent = formatFinancialYear(baseYearStart + index); 
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.classList.add('projection-input');
                  const value = row[metric]?.[yearKey];
                  input.value = typeof value === 'number' ? value.toFixed(2) : (value ?? 'N/A');
                  input.dataset.field = `${metric}.${yearKey}`;
                  input.dataset.id = row.id;
                  
                  if (isEditable && index > 0) {
                      input.readOnly = false;
                  } else {
                      input.readOnly = true;
                  }
                  if(isEditable) {
                      if (baselineRow && baselineRow[metric]?.[yearKey] !== row[metric]?.[yearKey]) {
                          input.classList.add('changed');
                      }
                  }
                  
                  item.appendChild(label);
                  item.appendChild(input);
                  yearInputsContainer.appendChild(item);
              });
              card.appendChild(yearInputsContainer);
              projectionsGrid.appendChild(card);
          });
          panel.appendChild(projectionsGrid);
          modalityContainer.appendChild(panel);
        }
        app.appendChild(modalityContainer);
      }
      activePanelIds.forEach(panelId => {
        const panelToReopen = document.getElementById(panelId);
        const buttonToReactivate = document.querySelector(`.archetype-button[data-target="#${panelId}"]`);
        if (panelToReopen) panelToReopen.classList.add('active');
        if (buttonToReactivate) buttonToReactivate.classList.add('active');
      });
    }
  </script>
</body>
</html>
