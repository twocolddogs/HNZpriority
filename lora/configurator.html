<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LORA Scenario Configurator</title>
  <!-- The styles.css file is now self-contained in the <style> tag below -->
  <style>
    /* ==========================================================================
       1. Global Styles & Keyframes
       ========================================================================== */
    @keyframes slideInDownCentered { from { transform: translate(-50%, -150%); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 167, 38, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(255, 167, 38, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 167, 38, 0); } }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ==========================================================================
       2. Core App Structure & Layout
       ========================================================================== */
    body {
      font-family: 'Public Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #F9FAFB;
      min-height: 100vh;
      color: #4B5563;
      line-height: 1.6;
    }
    .hidden { display: none !important; }
    .rtt-container {
      max-width: 1600px;
      margin: 1em auto;
    }
    .rtt-sticky-header {
      position: sticky;
      top: 0;
      z-index: 1002;
      background: #F9FAFB;
      padding-bottom: 0.4em;
    }
    .rtt-brand-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(90deg,#143345 45%,#41236a 100%);
      padding: 0.6em 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      margin-bottom: 1.5rem;
    }
    .rtt-app-logo { height: auto; margin-right: 1.5em; width: 160px; flex-shrink: 0; }
    .rtt-header-divider { width: 1px; height: 30px; background: rgba(255,255,255,0.3); margin-right: 1.5em; flex-shrink: 0; }
    .rtt-title { color: #fff; font-size: 1.5em; margin: 0; font-weight: 600; font-family: 'Poppins', sans-serif; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .rtt-flex-spacer { flex-grow: 1; }
    .rtt-header-controls { display: flex; align-items: center; gap: 1.5rem; flex-shrink: 0; }
    .scenario-controls { display: flex; background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 4px; position: relative; height: 44px; box-sizing: border-box; }
    .scenario-controls input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; width: 0; height: 0; }
    .scenario-controls label { padding: 0 1.75rem; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem; color: rgba(255, 255, 255, 0.7); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: none; position: relative; z-index: 2; flex: 1; text-align: center; user-select: none; background: transparent; height: 100%; display: flex; align-items: center; justify-content: center; }
    .scenario-controls label:hover { color: rgba(255, 255, 255, 0.9); }
    .scenario-controls .scenario-switch-bg { position: absolute; top: 4px; left: 4px; width: calc(50% - 4px); height: calc(100% - 8px); background: #fff; border-radius: 6px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1; }
    #source-scenario:checked ~ .scenario-switch-bg { transform: translateX(100%); }
    .scenario-controls input[type="radio"]:checked + label { color: #143345; }

    /* ==========================================================================
       3. Buttons, Inputs & File Upload
       ========================================================================== */
    .rtt-download-btn { font-family: 'Poppins', sans-serif; font-size: 0.9em; font-weight: 600; padding: 0.6em 1.2em; border: 1px solid #3a5c24; border-radius: 6px; background: #4c7a30; color: #fff; cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem; transition: all 0.2s ease; min-height: 44px; white-space: nowrap; }
    .rtt-download-btn:hover { background: #3e6326; border-color: #2f4a1c; }
    .rtt-download-btn:disabled { background: #9ca3af; border-color: #6b7280; cursor: not-allowed; }
    .loading-spinner { display: inline-block; width: 18px; height: 18px; border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: white; animation: spin 0.8s ease-in-out infinite; }
    input[type="text"] { box-sizing: border-box; width: 100%; padding: 0.5em 0.75em; border: 1px solid #D1D5DB; border-radius: 6px; font-size: 0.9rem; text-align: center; background-color: #fff; box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.07); transition: all 0.2s ease; min-height: 40px; }
    input[type="text"]:focus { outline: none; border-color: #007A86; box-shadow: 0 0 0 3px rgba(0, 122, 134, 0.15); }
    input[readonly], input:disabled { background-color: #F3F4F6; color: #6B7280; cursor: not-allowed; box-shadow: none; border-color: #E5EAF0; opacity: 0.7; }
    input.changed { border-color: #FFA726 !important; background-color: #FFF7E6 !important; }
    .scenario-name-card { background: #fff; border: 1px solid #E0E6ED; border-radius: 12px; margin-bottom: 2rem; overflow: hidden; }
    .scenario-name-header { background: #E8F0F6; padding: 1em 1.25em; color: #00549F; font-weight: 600; font-family: 'Poppins', sans-serif; font-size: 1.1em; border-bottom: 1px solid #D1D9E1; }
    .scenario-name-header h2 { margin: 0; font-size: inherit; font-weight: inherit; }
    .scenario-name-content { padding: 1.5em; }
    .scenario-name-content label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
    .scenario-name-content input { text-align: left; padding: 0.6em 0.8em; font-size: 1rem; max-width: 400px; }
    .file-upload { border: 2px dashed #ccc; border-radius: 8px; padding: 40px 20px; text-align: center; background-color: #ffffff; margin: 20px; max-width: 600px; margin-left: auto; margin-right: auto; }

    /* ==========================================================================
       4. Tab & Table Layout
       ========================================================================== */
    .tabs-nav {
      display: flex;
      gap: 0.25rem;
      border-bottom: 2px solid #D1D9E1;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    .tab-button {
      padding: 0.8em 1.5em;
      font-size: 1rem;
      font-weight: 600;
      color: #4B5563;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      margin-bottom: -2px;
      transition: all 0.2s ease-in-out;
      font-family: 'Poppins', sans-serif;
      position: relative;
    }
    .tab-button:hover {
      background: #F3F4F6;
      color: #1F2937;
    }
    .tab-button.active {
      color: #00549F;
      border-color: #00549F;
    }
    .tab-button.has-changes::after {
      content: '';
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      width: 8px;
      height: 8px;
      background-color: #FFA726;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; animation: fadeIn 0.5s ease; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    .tab-panel h3, .tab-panel .metric-title-wrapper {
        font-size: 1.4em; font-weight: 600; color: #143345; margin: 2rem 0 1.5rem 0;
        padding-bottom: 0.5rem; border-bottom: 1px solid #E0E6ED; font-family: 'Poppins', sans-serif;
        display: flex; align-items: center; gap: 0.75rem;
    }
    .tab-panel .metric-title-wrapper { font-size: 1.2em; margin-top: 2.5rem; }
    .tab-panel h4 { margin:0; padding: 0; border: 0; font-family: inherit; font-size: inherit; }

    .table-container {
      overflow-x: auto;
      background: #fff;
      border: 1px solid #E0E6ED;
      border-radius: 8px;
      padding: 0.5rem;
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
      white-space: nowrap;
    }
    .data-table th, .data-table td {
      padding: 0.75rem 1rem;
      text-align: center;
      vertical-align: middle;
      border: 1px solid #E5EAF0;
    }
    .data-table th {
      background-color: #F9FAFB;
      font-weight: 600;
      color: #374151;
      font-size: 0.9em;
    }
    .data-table th .th-content { display: flex; align-items: center; gap: 8px; justify-content: center;}
    .data-table td:first-child, .data-table th:first-child {
      text-align: left;
      font-weight: 600;
      position: sticky;
      left: 0;
      background-color: #F9FAFB;
      z-index: 1;
      min-width: 120px;
    }
    .data-table th:first-child .th-content { justify-content: flex-start; }
    .data-table td:first-child { background-color: #fff; }
    .data-table td.changed {
      box-shadow: inset 3px 0 0 #FFA726;
    }
    /* ==========================================================================
       5. Interactive Input/Slider & Tooltips
       ========================================================================== */
    .input-slider-wrapper {
      position: relative;
      min-width: 120px;
    }
    .slider-container {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      top: calc(100% + 5px);
      left: 0;
      right: 0;
      z-index: 20;
      background: #fff;
      padding: 1rem;
      border: 1px solid #B0B6BF;
      border-radius: 6px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.15);
      transition: opacity 0.2s, visibility 0.2s;
    }
    .slider-container.visible {
      visibility: visible;
      opacity: 1;
    }
    input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #E5EAF0; border-radius: 5px; outline: none; cursor: pointer; margin: 0; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #00549F; cursor: pointer; border-radius: 50%; border: 3px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2); margin-top: -6px; }
    input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; background: #00549F; cursor: pointer; border-radius: 50%; border: 3px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
    
    .info-container { position: relative; display: inline-flex; }
    .info-icon { display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; background-color: #B0B6BF; color: white; font-size: 12px; font-weight: bold; cursor: pointer; transition: background-color 0.2s; user-select: none; flex-shrink: 0; }
    .info-icon:hover { background-color: #00549F; }
    .info-tooltip { position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%); background: #333D47; color: white; padding: 0.75rem 1rem; border-radius: 6px; font-size: 0.9em; line-height: 1.5; width: 280px; max-width: 90vw; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 30; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
    .info-tooltip.visible { opacity: 1; visibility: visible; }
    .info-tooltip::after { content: ''; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); border-width: 6px; border-style: solid; border-color: #333D47 transparent transparent transparent; }

    /* ==========================================================================
       6. Status Messages & Responsive
       ========================================================================== */
    .status-message { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 9999; animation: slideInDownCentered 0.4s; }
    .status-message p { padding: 1em 1.5em; border-radius: 8px; color: white; font-weight: 600; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); margin: 0; white-space: nowrap; }
    .status-message .success { background: #28a745; }
    .status-message .error { background: #d9534f; }
    @media (max-width: 768px) {
        body { margin: 0.5em; }
        .rtt-container { margin: 0; }
        .rtt-sticky-header { top: 0; }
        .rtt-brand-bar { flex-wrap: wrap; gap: 1rem; padding: 0.8em 1em; }
        .rtt-header-controls { flex-basis: 100%; justify-content: space-between; }
        .data-table th, .data-table td { padding: 0.5rem; font-size: 0.85rem; }
    }
  </style>
</head>
<body>
  <div class="rtt-container">
    <header class="rtt-sticky-header">
      <div class="rtt-brand-bar">
        <img src="../images/HealthNZ_logo_v2.svg" alt="Health NZ Logo" class="rtt-app-logo">
        <div class="rtt-header-divider"></div>
        <h1 class="rtt-title">LORA Scenario Configurator</h1>
        <div class="rtt-flex-spacer"></div>
        <div id="header-controls-wrapper" class="hidden">
          <div class="rtt-header-controls">
            <div class="scenario-controls" id="scenario-toggle">
              <input type="radio" id="source-baseline" name="data-source" value="baseline" checked>
              <label for="source-baseline">Baseline</label>
              <input type="radio" id="source-scenario" name="data-source" value="scenario">
              <label for="source-scenario">Scenario</label>
              <span class="scenario-switch-bg" aria-hidden="true"></span>
            </div>
            <button id="export-button" class="rtt-download-btn">
              <span id="export-spinner" class="loading-spinner hidden"></span>
              Export CSV
            </button>
          </div>
        </div>
      </div>
      <div id="tabs-nav-container"></div>
    </header>

    <main id="main-content">
      <div id="file-upload-area" class="file-upload hidden">
        <h3>Load Configuration Data</h3>
        <p>Drag & drop your CSV file here, or click to select.</p>
        <div class="file-input">
          <input type="file" id="csv-file-input" accept=".csv" />
          <label for="csv-file-input">Choose File</label>
        </div>
      </div>
      <div id="scenario-name-card" class="scenario-name-card hidden">
        <div class="scenario-name-header"><h2>Scenario Name</h2></div>
        <div class="scenario-name-content">
          <label for="scenario-name-input">Enter a name for your scenario:</label>
          <input type="text" id="scenario-name-input" placeholder="e.g., High Growth Projection">
        </div>
      </div>
      <div id="app">
        <div class="app-loading-message">Loading Configuration...</div>
      </div>
    </main>
    
    <div id="status-message" class="status-message"></div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script>
    // --- Data Definitions ---
    const staticFields = ["non_demographic_growth", "routine_machine_hours", "share_of_scans_during_day", "ooh_machines", "ras_per_routine_machine_hour", "mit_shift_length", "mit_weeks_lost", "session_length_hours", "clinical_reporting_sessions_per_rad", "rad_weeks_lost"];
    const staticFieldLabels = { "non_demographic_growth": "Non-Demographic Growth", "routine_machine_hours": "Routine Machine Hours", "share_of_scans_during_day": "Share of Scans During Day", "ooh_machines": "OOH Machines", "ras_per_routine_machine_hour": "RAs per Routine Hour", "mit_shift_length": "MIT Shift Length", "mit_weeks_lost": "MIT Weeks Lost", "session_length_hours": "Session Length (Hrs)", "clinical_reporting_sessions_per_rad": "Rad Reporting Sessions", "rad_weeks_lost": "Rad Weeks Lost" };
    const staticFieldDescriptions = { "non_demographic_growth": "Non-demographic growth is a % change to apply over and above demographic growth (which comes from population projections). This varies by Modality.", "routine_machine_hours": "Routine machine hours provides the number of hours one machine of that modality would be expected to run in a normal working week.", "share_of_scans_during_day": "This is the % of events that occurred during routine hours which sets the level of activity to meet in hours.", "ooh_machines": "This is the number of machines each archetype is expected to run out of hours (OOH).", "ras_per_routine_machine_hour": "Radiology Assistants (RAs) support efficient delivery of CT and MR modalities. This ratio provides the number of RAs needed per routine machine hour.", "mit_shift_length": "MITs run the modalities and so to identify their FTE requirements we need to set the shift length they will work. This is strictly 4 hours.", "mit_weeks_lost": "This is a factor to account for cover given the need for MITs to take leave.", "session_length_hours": "This is the length of a session that a radiologist reports on an event, this tends to be 4 hours.", "clinical_reporting_sessions_per_rad": "This provides the number of reporting sessions that each radiologist does per week - this varies by archetype as larger facilities have a broader set of responsibilities for radiologists.", "rad_weeks_lost": "This is a factor to account for cover given the need for radiologists to take leave." };
    const staticFieldSliderConfig = { non_demographic_growth: { min: -0.05, max: 0.1, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s.replace('%','')) / 100 }, routine_machine_hours: { min: 40, max: 84, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, share_of_scans_during_day: { min: 0.90, max: 1.00, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s.replace('%','')) / 100 }, ooh_machines: { min: 0, max: 4, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, ras_per_routine_machine_hour: { min: 0, max: 2, step: 0.1, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, mit_shift_length: { min: 4, max: 6, step: 1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, mit_weeks_lost: { min: 6, max: 8, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, session_length_hours: { min: 4, max: 5, step: 0.5, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, clinical_reporting_sessions_per_rad: { min: 2, max: 10, step: 0.5, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, rad_weeks_lost: { min: 10, max: 14, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, };
    
    const projectionMetrics = ["ip_volume_step", "op_volume_step", "scan_rate", "report_rate", "mits_per_routine_machine_hour", "mits_per_ooh_machine_hour"];
    const projectionMetricLabels = { "ip_volume_step": "Inpatient Volume Step Change", "op_volume_step": "Outpatient Volume Step Change", "scan_rate": "Scan Rate (Mins)", "report_rate": "Report Rate (Mins)", "mits_per_routine_machine_hour": "MITs per Routine Machine Hour", "mits_per_ooh_machine_hour": "MITs per OOH Machine Hour" };
    const projectionMetricDescriptions = { "ip_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "op_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "scan_rate": "These financial-year-based 10 fields provide the number of minutes required for modality to be scanning per event, which may change over time as technologies change. These vary by modality and archetype.", "report_rate": "These financial-year-based 10 fields provide the number of minutes required for a radiologist to report on an event, which may change over time as technologies change. These vary by modality and archetype", "mits_per_routine_machine_hour": "These financial-year-based 10 fields provide the number of MITs required in-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype.", "mits_per_ooh_machine_hour": "These financial-year-based 10 fields provide the number of MITs required out-of-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype." };

    const years = Array.from({ length: 11 }, (_, i) => `y${i}`);
    let baseYearStart = new Date().getFullYear(); 
    const archetypeSortOrder = { "X Small": 1, "Small": 2, "Medium": 3, "Large": 4, "X Large": 5, };

    // --- DOM Element Cache ---
    const app = document.getElementById("app");
    const mainContent = document.getElementById("main-content");
    const headerControlsWrapper = document.getElementById("header-controls-wrapper");
    const scenarioToggle = document.getElementById("scenario-toggle");
    const exportButton = document.getElementById("export-button");
    const fileUploadArea = document.getElementById("file-upload-area");
    const scenarioNameCard = document.getElementById("scenario-name-card");
    const scenarioNameInput = document.getElementById("scenario-name-input");
    const tabsNavContainer = document.getElementById("tabs-nav-container");

    // --- State Variables ---
    let baselineData = [], scenarioData = [], activeTabId = null, scenarioName = "";

    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        loadAndInitializeData();
        setupEventListeners();
    });

    // --- Event Listeners Setup ---
    function setupEventListeners() {
      scenarioToggle.addEventListener('change', (e) => {
        const isBaseline = e.target.value === 'baseline';
        renderUI(isBaseline ? baselineData : scenarioData, !isBaseline);
      });

      document.getElementById('csv-file-input').addEventListener('change', (e) => loadCSVFile(e.target.files[0]));
      scenarioNameInput.addEventListener('input', (e) => { scenarioName = e.target.value; });
      exportButton.addEventListener('click', exportScenarioCSV);
      
      tabsNavContainer.addEventListener('click', (e) => {
        const button = e.target.closest('.tab-button');
        if (!button) return;
        activeTabId = button.dataset.target;
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.toggle('active', btn === button));
        document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.toggle('active', panel.id === activeTabId));
      });
      
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.input-slider-wrapper')) hideAllSliders();
        if (!e.target.closest('.info-container')) {
             document.querySelectorAll('.info-tooltip.visible').forEach(tt => tt.classList.remove('visible'));
        }
      });
      
      mainContent.addEventListener('click', (e) => {
        if (e.target.classList.contains('info-icon')) {
            e.stopPropagation();
            const tooltip = e.target.nextElementSibling;
            const isVisible = tooltip.classList.contains('visible');
            document.querySelectorAll('.info-tooltip.visible').forEach(tt => tt.classList.remove('visible'));
            if (!isVisible) tooltip.classList.add('visible');
        }
      });

      app.addEventListener('focusin', (e) => {
        if (e.target.matches('.static-field-input')) {
            hideAllSliders();
            const wrapper = e.target.closest('.input-slider-wrapper');
            if (wrapper) wrapper.querySelector('.slider-container')?.classList.add('visible');
        }
      });
      
      app.addEventListener('input', handleDataInput);
      app.addEventListener('change', handleDataChange);
    }

    // --- Data Loading & Processing ---
    async function loadAndInitializeData() {
        showLoadingMessage("Loading baseline configuration...");
        try {
            const response = await fetch('input_configuration_snowflake_baseline_2023_2024.csv');
            if (!response.ok) throw new Error('Primary CSV not found, trying fallback.');
            const csvText = await response.text();
            processCSV(csvText, "Successfully loaded baseline data.");
        } catch (error) {
            console.warn(error.message);
            try {
                const fallbackResponse = await fetch('baseline.csv');
                if (!fallbackResponse.ok) throw new Error('Fallback CSV not found.');
                const csvText = await fallbackResponse.text();
                processCSV(csvText, "Successfully loaded baseline data.");
            } catch (fallbackError) {
                console.error("Could not auto-load any CSV:", fallbackError);
                app.innerHTML = '';
                fileUploadArea.classList.remove('hidden');
            }
        }
    }

    function loadCSVFile(file) {
      if (file && (file.type === "text/csv" || file.name.endsWith('.csv'))) {
        Papa.parse(file, {
          header: true, skipEmptyLines: true, dynamicTyping: true,
          complete: (results) => processCSV(results, "Successfully loaded uploaded file."),
          error: (err) => showMessage("Error reading the file.", "error")
        });
      } else {
        showMessage("Please select a valid .csv file.", "error");
      }
    }

    function processCSV(csvData, successMessage) {
        const results = (typeof csvData === 'string') ? Papa.parse(csvData, { header: true, skipEmptyLines: true, dynamicTyping: true }) : csvData;

        if (results.errors.length) {
            console.error("CSV Parsing Errors:", results.errors);
            return showMessage("Error parsing CSV file.", "error");
        }

        const processedData = results.data.map(row => {
            const newRow = { ...row };
            projectionMetrics.forEach(metric => {
                newRow[metric] = {};
                years.forEach(yearKey => {
                    newRow[metric][yearKey] = row[`${metric}_${yearKey}`];
                    delete newRow[`${metric}_${yearKey}`];
                });
            });
            newRow.id = `${newRow.modality}-${newRow.archetype}`.replace(/\s+/g, '-').toLowerCase();
            return newRow;
        });

        const firstRow = processedData[0];
        if (firstRow && firstRow.baseyear) {
            const parsedYear = parseInt(String(firstRow.baseyear).substring(0, 4), 10);
            if (!isNaN(parsedYear)) baseYearStart = parsedYear;
        }

        baselineData = JSON.parse(JSON.stringify(processedData));
        scenarioData = JSON.parse(JSON.stringify(processedData));
        activeTabId = null; scenarioName = "";

        fileUploadArea.classList.add('hidden');
        headerControlsWrapper.classList.remove('hidden');
        document.querySelector('.app-loading-message')?.classList.add('hidden');
        
        renderUI(baselineData, false);
        showMessage(successMessage, "success");
    }

    // --- UI Rendering ---
    function renderUI(data, isEditable) {
      app.innerHTML = '';
      tabsNavContainer.innerHTML = '';
      scenarioNameCard.classList.toggle('hidden', !isEditable);
      if(isEditable) scenarioNameInput.value = scenarioName;

      const groupedByModality = data.reduce((acc, row) => {
        (acc[row.modality] = acc[row.modality] || []).push(row);
        return acc;
      }, {});
      
      const modalities = Object.keys(groupedByModality).sort();
      if (!activeTabId || !groupedByModality[activeTabId.replace('tab-','')]) {
         activeTabId = `tab-${modalities[0]?.toLowerCase().replace(/\s/g, '-')}`;
      }

      const nav = document.createElement('div');
      nav.className = 'tabs-nav';
      modalities.forEach(modality => {
        const tabId = `tab-${modality.toLowerCase().replace(/\s/g, '-')}`;
        const button = document.createElement('button');
        button.className = 'tab-button';
        button.classList.toggle('active', tabId === activeTabId);
        if (isEditable) {
          button.classList.toggle('has-changes', groupedByModality[modality].some(row => hasRowChanged(row.id)));
        }
        button.dataset.target = tabId;
        button.textContent = modality;
        nav.appendChild(button);
      });
      tabsNavContainer.appendChild(nav);
      
      modalities.forEach(modality => {
        const tabId = `tab-${modality.toLowerCase().replace(/\s/g, '-')}`;
        const panel = document.createElement('div');
        panel.id = tabId;
        panel.className = 'tab-panel';
        panel.classList.toggle('active', tabId === activeTabId);
        
        const archetypes = groupedByModality[modality].sort((a,b) => (archetypeSortOrder[a.archetype] || 99) - (archetypeSortOrder[b.archetype] || 99));

        panel.appendChild(createTableTitle('h3', 'Static Fields'));
        panel.appendChild(createStaticTable(archetypes, isEditable));

        projectionMetrics.forEach(metric => {
            const titleWrapper = createTableTitle('div', projectionMetricLabels[metric], projectionMetricDescriptions[metric]);
            titleWrapper.classList.add('metric-title-wrapper');
            panel.appendChild(titleWrapper);
            panel.appendChild(createProjectionTable(archetypes, metric, isEditable));
        });
        
        app.appendChild(panel);
      });
    }
    
    function createTableTitle(tag, title, description) {
        const wrapper = document.createElement(tag);
        const titleEl = document.createElement(tag === 'div' ? 'h4' : 'span');
        titleEl.textContent = title;
        wrapper.appendChild(titleEl);

        if (description) {
            const infoContainer = document.createElement('div');
            infoContainer.className = 'info-container';
            const infoIcon = document.createElement('span');
            infoIcon.className = 'info-icon';
            infoIcon.textContent = '?';
            const tooltip = document.createElement('div');
            tooltip.className = 'info-tooltip';
            tooltip.textContent = description;
            infoContainer.appendChild(infoIcon);
            infoContainer.appendChild(tooltip);
            wrapper.appendChild(infoContainer);
        }
        return wrapper;
    }

    function createStaticTable(archetypes, isEditable) {
        const tableContainer = document.createElement('div');
        tableContainer.className = 'table-container';
        const table = document.createElement('table');
        table.className = 'data-table';
        
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const firstTh = document.createElement('th');
        firstTh.textContent = 'Archetype';
        headerRow.appendChild(firstTh);

        staticFields.forEach(f => {
            const th = document.createElement('th');
            const contentDiv = document.createElement('div');
            contentDiv.className = 'th-content';
            contentDiv.textContent = staticFieldLabels[f];
            const infoContainer = createTableTitle('div', '', staticFieldDescriptions[f]).querySelector('.info-container');
            if(infoContainer) contentDiv.appendChild(infoContainer);
            th.appendChild(contentDiv);
            headerRow.appendChild(th);
        });

        const tbody = table.createTBody();
        archetypes.forEach(row => {
            const tr = tbody.insertRow();
            tr.insertCell().textContent = row.archetype;
            staticFields.forEach(field => {
                const td = tr.insertCell();
                const config = staticFieldSliderConfig[field];
                if (!config) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'input-slider-wrapper';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'static-field-input';
                const value = row[field];
                input.value = (value !== null && typeof value !== 'undefined' && !isNaN(value)) ? config.format(value) : 'N/A';
                input.dataset.id = row.id;
                input.dataset.field = field;
                input.readOnly = !isEditable;
                wrapper.appendChild(input);

                if (isEditable) {
                    const baselineRow = baselineData.find(br => br.id === row.id);
                    if (Math.abs(parseFloat(value) - parseFloat(baselineRow[field])) > 1e-9) {
                        td.classList.add('changed');
                    }
                    const sliderContainer = document.createElement('div');
                    sliderContainer.className = 'slider-container';
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = config.min; slider.max = config.max; slider.step = config.step;
                    slider.value = value;
                    sliderContainer.appendChild(slider);
                    wrapper.appendChild(sliderContainer);
                }
                td.appendChild(wrapper);
            });
        });
        tableContainer.appendChild(table);
        return tableContainer;
    }

    function createProjectionTable(archetypes, metric, isEditable) {
        const tableContainer = document.createElement('div');
        tableContainer.className = 'table-container';
        const table = document.createElement('table');
        table.className = 'data-table';

        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        headerRow.innerHTML = `<th>Archetype</th>` + years.map((_, i) => `<th>FY ${String(baseYearStart + i).slice(-2)}/${String(baseYearStart + i + 1).slice(-2)}</th>`).join('');

        const tbody = table.createTBody();
        archetypes.forEach(row => {
            const tr = tbody.insertRow();
            tr.insertCell().textContent = row.archetype;
            years.forEach(yearKey => {
                const td = tr.insertCell();
                const input = document.createElement('input');
                input.type = 'text';
                const value = row[metric]?.[yearKey];
                input.value = (value !== null && typeof value !== 'undefined' && !isNaN(value)) ? value.toFixed(2) : 'N/A';
                input.dataset.id = row.id;
                input.dataset.field = `${metric}.${yearKey}`;
                input.readOnly = !isEditable || yearKey === 'y0';

                if (isEditable && baselineData.find(br => br.id === row.id)[metric]?.[yearKey] !== value) {
                    td.classList.add('changed');
                }
                td.appendChild(input);
            });
        });
        tableContainer.appendChild(table);
        return tableContainer;
    }

    // --- Event Handling Logic ---
    function handleDataInput(e) {
        const slider = e.target;
        if (slider.type !== 'range') return;
        
        const textInput = slider.closest('.input-slider-wrapper').querySelector('input[type=text]');
        const { id: rowId, field: fieldKey } = textInput.dataset;
        const config = staticFieldSliderConfig[fieldKey];
        const rowToUpdate = scenarioData.find(row => row.id === rowId);

        if (!rowToUpdate || !config) return;

        const newValue = parseFloat(slider.value);
        textInput.value = config.format(newValue);
        rowToUpdate[fieldKey] = newValue;
        updateChangeState(rowId, fieldKey);
    }

    function handleDataChange(e) {
        const textInput = e.target;
        if (textInput.type !== 'text' || !textInput.dataset.id) return;

        const { id: rowId, field: fieldKey } = textInput.dataset;
        const rowToUpdate = scenarioData.find(row => row.id === rowId);
        if (!rowToUpdate) return;
        
        if (staticFields.includes(fieldKey)) {
            const config = staticFieldSliderConfig[fieldKey];
            if (!config) return;
            let parsedValue = config.parse(textInput.value);
            if (isNaN(parsedValue)) {
                return textInput.value = config.format(rowToUpdate[fieldKey]);
            }
            const clampedValue = Math.max(config.min, Math.min(config.max, parsedValue));
            rowToUpdate[fieldKey] = clampedValue;
            textInput.value = config.format(clampedValue);
            const slider = textInput.closest('.input-slider-wrapper').querySelector('input[type=range]');
            if (slider) slider.value = clampedValue;
        } 
        else {
            const [metric, yearKey] = fieldKey.split('.');
            const numericValue = parseFloat(textInput.value);
            if (isNaN(numericValue)) {
                textInput.value = rowToUpdate[metric][yearKey].toFixed(2);
            } else {
                rowToUpdate[metric][yearKey] = numericValue;
                textInput.value = numericValue.toFixed(2);
            }
        }
        updateChangeState(rowId, fieldKey);
    }
    
    // --- State Update & Utility Functions ---
    function updateChangeState(rowId, fieldKey) {
        const rowToUpdate = scenarioData.find(row => row.id === rowId);
        const baselineRow = baselineData.find(row => row.id === rowId);
        const cell = document.querySelector(`input[data-id="${rowId}"][data-field="${fieldKey}"]`).closest('td');
        if (!cell) return;

        let isChanged = false;
        if (staticFields.includes(fieldKey)) {
            isChanged = Math.abs(parseFloat(rowToUpdate[fieldKey]) - parseFloat(baselineRow[fieldKey])) > 1e-9;
        } else {
            const [metric, yearKey] = fieldKey.split('.');
            isChanged = rowToUpdate[metric]?.[yearKey] !== baselineRow[metric]?.[yearKey];
        }
        cell.classList.toggle('changed', isChanged);

        const modality = rowToUpdate.modality;
        const tabButton = document.querySelector(`.tab-button[data-target="tab-${modality.toLowerCase().replace(/\s/g, '-')}"]`);
        if (tabButton) {
            tabButton.classList.toggle('has-changes', scenarioData.filter(r => r.modality === modality).some(r => hasRowChanged(r.id)));
        }
    }

    function hasRowChanged(rowId) {
        const scenarioRow = scenarioData.find(r => r.id === rowId);
        const baselineRow = baselineData.find(r => r.id === rowId);
        if (!scenarioRow || !baselineRow) return false;
        return staticFields.some(key => Math.abs(parseFloat(scenarioRow[key]) - parseFloat(baselineRow[key])) > 1e-9) || 
               projectionMetrics.some(metric => years.some(yearKey => scenarioRow[metric]?.[yearKey] !== baselineRow[metric]?.[yearKey]));
    }
    
    function exportScenarioCSV() {
        const spinner = document.getElementById('export-spinner');
        spinner.classList.remove('hidden');
        exportButton.disabled = true;

        setTimeout(() => { 
            const flatData = scenarioData.map(row => {
                const newFlatRow = { ...row };
                projectionMetrics.forEach(metric => {
                    if (newFlatRow[metric]) {
                        years.forEach(yearKey => {
                            newFlatRow[`${metric}_${yearKey}`] = newFlatRow[metric][yearKey];
                        });
                        delete newFlatRow[metric];
                    }
                });
                return newFlatRow;
            });

            const csv = Papa.unparse(flatData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            const filename = (scenarioName.trim().replace(/\s+/g, '_') || 'scenario_export') + `_${new Date().toISOString().slice(0,10)}.csv`;
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            spinner.classList.add('hidden');
            exportButton.disabled = false;
            showMessage("CSV exported successfully!", "success");
        }, 500);
    }

    function hideAllSliders() {
        document.querySelectorAll('.slider-container.visible').forEach(slider => slider.classList.remove('visible'));
    }

    function showLoadingMessage(message) {
        app.innerHTML = `<div class="app-loading-message">${message}</div>`;
    }

    function showMessage(message, type = 'info') {
        const statusMessage = document.getElementById('status-message');
        const p = document.createElement('p');
        p.className = type;
        p.textContent = message;
        statusMessage.innerHTML = '';
        statusMessage.appendChild(p);
        setTimeout(() => { statusMessage.innerHTML = ''; }, 3000);
    }
</script>
</body>
</html>
