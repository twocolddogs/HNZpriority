<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LORA Scenario Configurator</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="rtt-container">
    <header class="rtt-sticky-header">
      <div class="rtt-brand-bar">
        <img src="../images/HealthNZ_logo_v2.svg" alt="Health NZ Logo" class="rtt-app-logo">
        <div class="rtt-header-divider"></div>
        <h1 class="rtt-title">LORA Scenario Configurator</h1>
        <div class="rtt-flex-spacer"></div>
        <div id="header-controls-wrapper" class="hidden">
          <div class="rtt-header-controls">
            <div class="scenario-controls" id="scenario-toggle">
              <input type="radio" id="source-baseline" name="data-source" value="baseline" checked>
              <label for="source-baseline">Baseline</label>
              <input type="radio" id="source-scenario" name="data-source" value="scenario">
              <label for="source-scenario">Scenario</label>
              <span class="scenario-switch-bg" aria-hidden="true"></span>
            </div>
            <div id="actions-menu-container" class="actions-menu-container hidden">
              <button id="actions-menu-button" class="rtt-hamburger-btn">
                <span></span>
                <span></span>
                <span></span>
              </button>
              <ul id="actions-dropdown-menu" class="actions-dropdown-menu hidden">
                <li id="menu-save-draft" class="hidden"><button>Save Draft</button></li>
                <li id="menu-import-draft"><button>Import Draft</button></li>
                <li class="menu-divider hidden"></li>
                <li id="menu-reset" class="hidden"><button>Reset Scenario</button></li>
                <li id="menu-export" class="hidden"><button>Export CSV</button></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main id="main-content">
       <div id="baseline-name-card" class="name-card hidden">
        <div class="name-card-header"><h2>Baseline Details</h2></div>
        <div class="name-card-content">
          <p id="baseline-name-display">Default Baseline</p>
          <p id="baseline-description-display" class="description-text"></p>
        </div>
      </div>
      <div id="scenario-name-card" class="name-card hidden">
        <div class="name-card-header"><h2>Scenario Details</h2></div>
        <div class="name-card-content">
          <label for="scenario-name-input">Enter a name for your scenario:</label>
          <input type="text" id="scenario-name-input" placeholder="e.g., High Growth Projection">
          <label for="scenario-description-input" class="scenario-description-label">Enter a description for your scenario:</label>
          <textarea id="scenario-description-input" rows="3" placeholder="e.g., This scenario models the impact of new screening programs and technology changes."></textarea>
        </div>
      </div>
      
      <div id="sticky-tabs-wrapper">
        <div id="tabs-nav-container"></div>
      </div>

      <div id="file-upload-area" class="file-upload hidden">
        <h3>Load Configuration Data</h3>
        <p>Drag & drop your CSV file here, or click to select.</p>
        <div class="file-input">
          <input type="file" id="csv-file-input" accept=".csv" />
          <label for="csv-file-input">Choose File</label>
        </div>
      </div>
      
      <div id="app">
        <div class="app-loading-message">Loading Configuration...</div>
      </div>
    </main>
    
    <div id="status-message" class="status-message"></div>
    <div id="global-tooltip" class="global-tooltip"></div>
  </div>

  <div id="import-draft-modal-overlay" class="modal-overlay hidden">
    <div class="modal-container">
        <h2 class="modal-title">Import Scenario Draft</h2>
        <p class="modal-body-text">Select a `.lora-draft` file to load your saved scenario. This will overwrite any current changes.</p>
        <div class="file-upload-modal-content">
            <div class="file-input">
                <input type="file" id="draft-file-input" accept=".lora-draft,.json" />
                <label for="draft-file-input">Choose Draft File</label>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="import-draft-modal-close-btn" class="modal-btn modal-btn-cancel">Close</button>
        </div>
    </div>
  </div>

  <div id="info-modal-overlay" class="modal-overlay hidden">
    <div class="modal-container">
      <h2 class="modal-title">Read-Only View</h2>
      <p class="modal-body-text">
        This view is read-only. To make changes, please switch to "Scenario" view using the toggle in the header.
      </p>
      <div class="modal-buttons">
        <button id="info-modal-ok-btn" class="modal-btn modal-btn-confirm">OK</button>
      </div>
    </div>
  </div>

  <div id="reset-modal-overlay" class="modal-overlay hidden">
    <div class="modal-container">
      <h2 class="modal-title">Reset Scenario</h2>
      <p class="modal-body-text">
        Are you sure you want to reset all changes in this scenario? This will revert all values to the baseline. This action cannot be undone.
      </p>
      <div class="modal-buttons">
        <button id="reset-modal-cancel-btn" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="reset-modal-confirm-btn" class="modal-btn modal-btn-confirm">Confirm Reset</button>
      </div>
    </div>
  </div>

  <div id="projection-modal-overlay" class="modal-overlay hidden">
    <div id="projection-modal-container" class="modal-container">
      <h2 class="modal-title">Apply Bulk Change</h2>
      <div class="modal-options">
        <div class="modal-toggle-group">
          <label for="toggle-subsequent-years">Apply to all subsequent years?</label>
          <label class="toggle-switch">
            <input type="checkbox" id="toggle-subsequent-years" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="modal-toggle-group">
          <label for="toggle-all-modalities">Apply across all modalities?</label>
          <label class="toggle-switch">
            <input type="checkbox" id="toggle-all-modalities">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="projection-modal-cancel" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="projection-modal-confirm" class="modal-btn modal-btn-confirm">Confirm</button>
      </div>
    </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script>
    // --- Data Definitions (UNCHANGED) ---
const staticFields = ["non_demographic_growth", "routine_machine_hours", "share_of_scans_during_day", "ooh_machines", "ras_per_routine_machine_hour", "mit_shift_length", "mit_weeks_lost", "session_length_hours", "clinical_reporting_sessions_per_rad", "rad_weeks_lost"];
const staticFieldLabels = { "non_demographic_growth": "Non-Demographic Growth", "routine_machine_hours": "Routine Machine Hours", "share_of_scans_during_day": "Share of Scans During Day", "ooh_machines": "OOH Machines", "ras_per_routine_machine_hour": "RAs per Routine Hour", "mit_shift_length": "MIT Shift Length", "mit_weeks_lost": "MIT Weeks Lost", "session_length_hours": "Session Length (Hrs)", "clinical_reporting_sessions_per_rad": "Radiologist Reporting Sessions", "rad_weeks_lost": "Radiologist Weeks Lost" };
const staticFieldDescriptions = { "non_demographic_growth": "Non-demographic growth is a % change to apply over and above demographic growth (which comes from population projections). This varies by Modality.", "routine_machine_hours": "Routine machine hours provides the number of hours one machine of that modality would be expected to run in a normal working week.", "share_of_scans_during_day": "This is the % of events that occurred during routine hours which sets the level of activity to meet in hours.", "ooh_machines": "This is the number of machines each archetype is expected to run out of hours (OOH).", "ras_per_routine_machine_hour": "Radiology Assistants (RAs) support efficient delivery of CT and MR modalities. This ratio provides the number of RAs needed per routine machine hour.", "mit_shift_length": "MITs run the modalities and so to identify their FTE requirements we need to set the shift length they will work. This is strictly 4 hours.", "mit_weeks_lost": "This is a factor to account for cover given the need for MITs to take leave.", "session_length_hours": "This is the length of a session that a radiologist reports on an event, this tends to be 4 hours.", "clinical_reporting_sessions_per_rad": "This provides the number of reporting sessions that each radiologist does per week - this varies by archetype as larger facilities have a broader set of responsibilities for radiologists.", "rad_weeks_lost": "This is a factor to account for cover given the need for radiologists to take leave." };
const staticFieldSliderConfig = { non_demographic_growth: { min: -0.05, max: 0.1, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s.replace('%','')) / 100 }, routine_machine_hours: { min: 40, max: 84, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, share_of_scans_during_day: { min: 0.90, max: 1.00, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s.replace('%','')) / 100 }, ooh_machines: { min: 0, max: 4, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, ras_per_routine_machine_hour: { min: 0, max: 2, step: 0.1, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, mit_shift_length: { min: 4, max: 6, step: 1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, mit_weeks_lost: { min: 6, max: 8, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, session_length_hours: { min: 4, max: 5, step: 0.5, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, clinical_reporting_sessions_per_rad: { min: 2, max: 10, step: 0.5, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, rad_weeks_lost: { min: 10, max: 14, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, };
const staticFieldGroups = { 'Demand & Machine Assumptions': ['non_demographic_growth', 'routine_machine_hours', 'share_of_scans_during_day', 'ooh_machines'], 'Workforce': ['ras_per_routine_machine_hour', 'mit_shift_length', 'mit_weeks_lost', 'session_length_hours', 'clinical_reporting_sessions_per_rad', 'rad_weeks_lost'] };
const projectionMetrics = ["ip_volume_step", "op_volume_step", "scan_rate", "report_rate", "mits_per_routine_machine_hour", "mits_per_ooh_machine_hour"];
const projectionMetricLabels = { "ip_volume_step": "Inpatient Volume Step Change", "op_volume_step": "Outpatient Volume Step Change", "scan_rate": "Scan Rate (Mins)", "report_rate": "Report Rate (Mins)", "mits_per_routine_machine_hour": "MITs per Routine Machine Hour", "mits_per_ooh_machine_hour": "MITs per OOH Machine Hour" };
const projectionMetricDescriptions = { "ip_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "op_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "scan_rate": "These financial-year-based 10 fields provide the number of minutes required for modality to be scanning per event, which may change over time as technologies change. These vary by modality and archetype.", "report_rate": "These financial-year-based 10 fields provide the number of minutes required for a radiologist to report on an event, which may change over time as technologies change. These vary by modality and archetype", "mits_per_routine_machine_hour": "These financial-year-based 10 fields provide the number of MITs required in-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype.", "mits_per_ooh_machine_hour": "These financial-year-based 10 fields provide the number of MITs required out-of-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype." };
const projectionMetricConfig = { ip_volume_step: { min: -0.20, max: 0.20, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(String(s).replace('%','')) / 100 }, op_volume_step: { min: -0.20, max: 0.20, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(String(s).replace('%','')) / 100 }};
const modalityDisplayMap = { "MR": "MRI" };
const modalityIcons = { "CT": "CT.png", "US": "US.png", "XR": "XR.png", "MRI": "MRI.png" };
let archetypeDescriptions = { "X Small": "Loading facilities...", "Small": "Loading facilities...", "Medium": "Loading facilities...", "Large": "Loading facilities...", "X Large": "Loading facilities...", "Default": "No facility list available for this archetype." };
const years = Array.from({ length: 11 }, (_, i) => `y${i}`);
let baseYearStart = new Date().getFullYear(); 
const archetypeSortOrder = { "X Small": 1, "Small": 2, "Medium": 3, "Large": 4, "X Large": 5, };

// --- DOM Element Cache ---
const app = document.getElementById("app");
const mainContent = document.getElementById("main-content");
const headerControlsWrapper = document.getElementById("header-controls-wrapper");
const scenarioToggle = document.getElementById("scenario-toggle");
const fileUploadArea = document.getElementById("file-upload-area");
const scenarioNameCard = document.getElementById("scenario-name-card");
const scenarioNameInput = document.getElementById("scenario-name-input");
const scenarioDescriptionInput = document.getElementById("scenario-description-input");
const baselineNameCard = document.getElementById("baseline-name-card");
const baselineNameDisplay = document.getElementById("baseline-name-display");
const baselineDescriptionDisplay = document.getElementById("baseline-description-display");
const tabsNavContainer = document.getElementById("tabs-nav-container");
const globalTooltip = document.getElementById("global-tooltip");
// Menu Elements
const actionsMenuContainer = document.getElementById("actions-menu-container");
const actionsMenuButton = document.getElementById("actions-menu-button");
const actionsDropdownMenu = document.getElementById("actions-dropdown-menu");
const menuSaveDraft = document.getElementById("menu-save-draft");
const menuImportDraft = document.getElementById("menu-import-draft");
const menuReset = document.getElementById("menu-reset");
const menuExport = document.getElementById("menu-export");
const menuDivider = document.querySelector('.menu-divider');
// Modal Elements
const infoModalOverlay = document.getElementById("info-modal-overlay");
const infoModalOkBtn = document.getElementById("info-modal-ok-btn");
const projectionModalOverlay = document.getElementById("projection-modal-overlay");
const projectionModalConfirmBtn = document.getElementById("projection-modal-confirm");
const projectionModalCancelBtn = document.getElementById("projection-modal-cancel");
const toggleSubsequentYears = document.getElementById("toggle-subsequent-years");
const toggleAllModalities = document.getElementById("toggle-all-modalities");
const resetModalOverlay = document.getElementById("reset-modal-overlay");
const resetModalConfirmBtn = document.getElementById("reset-modal-confirm-btn");
const resetModalCancelBtn = document.getElementById("reset-modal-cancel-btn");
const importDraftModalOverlay = document.getElementById("import-draft-modal-overlay");
const importDraftModalCloseBtn = document.getElementById("import-draft-modal-close-btn");
const draftFileInput = document.getElementById("draft-file-input");


// --- State Variables ---
let baselineData = [], scenarioData = [];
let activeTabId = null;
let baselineName = "Default Baseline", scenarioName = "";
let baselineDescription = "", scenarioDescription = "", initialScenarioDescription = "";
let activeSubTabs = { 'static-fields': 'Demand & Machine Assumptions' };
let currentProjectionChangeContext = null;

// --- Tooltip System (UNCHANGED) ---
function showTooltip(triggerElement, content) {
    // This is a placeholder as full implementation details were not provided.
    // In a real app, you'd calculate position relative to triggerElement.
    globalTooltip.innerHTML = content;
    const triggerRect = triggerElement.getBoundingClientRect();
    globalTooltip.style.left = `${triggerRect.left + window.scrollX}px`;
    globalTooltip.style.top = `${triggerRect.bottom + window.scrollY + 5}px`;
    globalTooltip.classList.add('visible');
    triggerElement.classList.add('active');
}
function hideTooltip() {
    globalTooltip.classList.remove('visible');
    document.querySelectorAll('.info-icon.active').forEach(icon => icon.classList.remove('active'));
}

// --- Initial Setup ---
document.addEventListener('DOMContentLoaded', () => {
    loadArchetypeDescriptions();
    loadAndInitializeData();
    setupEventListeners();
});

// --- Event Listeners Setup ---
function setupEventListeners() {
  scenarioToggle.addEventListener('change', (e) => {
    const isBaseline = e.target.value === 'baseline';
    renderUI(isBaseline ? baselineData : scenarioData, !isBaseline);
  });

  document.getElementById('csv-file-input').addEventListener('change', (e) => loadCSVFile(e.target.files[0]));
  scenarioNameInput.addEventListener('input', (e) => { scenarioName = e.target.value; });
  scenarioDescriptionInput.addEventListener('input', (e) => { 
      scenarioDescription = e.target.value;
      updateHeaderButtonStates(true);
  });
  
  // Menu Listeners
  actionsMenuButton.addEventListener('click', (e) => {
      e.stopPropagation();
      actionsDropdownMenu.classList.toggle('hidden');
  });
  menuSaveDraft.addEventListener('click', saveDraft);
  menuImportDraft.addEventListener('click', () => {
      importDraftModalOverlay.classList.remove('hidden');
      actionsDropdownMenu.classList.add('hidden');
  });
  menuReset.addEventListener('click', showResetModal);
  menuExport.addEventListener('click', exportScenarioCSV);
  draftFileInput.addEventListener('change', (e) => loadDraft(e.target.files[0]));


  tabsNavContainer.addEventListener('click', (e) => {
    const button = e.target.closest('.tab-button');
    if (!button) return;
    activeTabId = button.dataset.target;
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.toggle('active', btn === button));
    document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.toggle('active', panel.id === activeTabId));
  });
  
  app.addEventListener('click', (e) => {
    const subNavButton = e.target.closest('.sub-nav-button');
    if (subNavButton) {
        const navId = subNavButton.parentElement.dataset.navId;
        const targetGroup = subNavButton.dataset.targetGroup;
        activeSubTabs[navId] = targetGroup;
        const tabPanel = subNavButton.closest('.tab-panel');
        tabPanel.dataset.staticFieldsSubtab = targetGroup.replace(/\s/g, '-').replace('&', 'and');
        subNavButton.parentElement.querySelectorAll('.sub-nav-button').forEach(btn => {
            btn.classList.toggle('active', btn === subNavButton);
        });
    }
  });
  
  document.addEventListener('click', (e) => {
    // Hide menu if clicked outside
    if (!actionsMenuContainer.contains(e.target)) {
        actionsDropdownMenu.classList.add('hidden');
    }
    const infoIcon = e.target.closest('.info-icon');
    if (infoIcon) {
        e.stopPropagation();
        const isCurrentlyActive = infoIcon.classList.contains('active');
        if (isCurrentlyActive) {
            hideTooltip();
        } else {
            const hiddenTooltip = infoIcon.nextElementSibling;
            if (hiddenTooltip && hiddenTooltip.classList.contains('info-tooltip')) {
                showTooltip(infoIcon, hiddenTooltip.innerHTML);
            }
        }
    } else {
        hideTooltip();
    }
    if (!e.target.closest('.input-slider-wrapper')) {
        hideAllSliders();
    }
  });

  app.addEventListener('focusin', (e) => {
    const isBaselineView = document.getElementById('source-baseline').checked;
    
    if (isBaselineView && (e.target.matches('input[type="text"]') || e.target.matches('textarea'))) {
        showInfoModal();
        e.target.blur(); 
        return; 
    }

    if (e.target.matches('.static-field-input')) {
        hideAllSliders();
        const wrapper = e.target.closest('.input-slider-wrapper');
        if (wrapper) wrapper.querySelector('.slider-container')?.classList.add('visible');
    }
  });
  
  app.addEventListener('input', handleDataInput);
  app.addEventListener('change', handleDataChange);

  // Modal Listeners
  infoModalOkBtn.addEventListener('click', hideInfoModal);
  infoModalOverlay.addEventListener('click', (e) => { if (e.target === infoModalOverlay) hideInfoModal(); });
  projectionModalConfirmBtn.addEventListener('click', handleProjectionConfirm);
  projectionModalCancelBtn.addEventListener('click', hideProjectionModal);
  projectionModalOverlay.addEventListener('click', (e) => { if (e.target === projectionModalOverlay) hideProjectionModal(); });
  resetModalConfirmBtn.addEventListener('click', handleResetConfirm);
  resetModalCancelBtn.addEventListener('click', hideResetModal);
  resetModalOverlay.addEventListener('click', (e) => { if (e.target === resetModalOverlay) hideResetModal(); });
  importDraftModalCloseBtn.addEventListener('click', () => importDraftModalOverlay.classList.add('hidden'));
  importDraftModalOverlay.addEventListener('click', (e) => { if (e.target === importDraftModalOverlay) importDraftModalOverlay.classList.add('hidden'); });
}

// --- Archetype Data Loading ---
async function loadArchetypeDescriptions() {
    try {
        const response = await fetch('archetypes.csv');
        if (!response.ok) throw new Error('Archetypes CSV not found');
        const csvText = await response.text();
        
        const results = Papa.parse(csvText, { 
            header: false, 
            skipEmptyLines: true 
        });
        
        // Group facilities by archetype
        const archetypeGroups = {
            "X Small": [],
            "Small": [],
            "Medium": [],
            "Large": [],
            "X Large": []
        };
        
        results.data.forEach(row => {
            const facility = row[0];
            const archetype = row[1];
            
            // Skip empty rows or header rows
            if (facility && archetype && archetypeGroups[archetype]) {
                archetypeGroups[archetype].push(facility);
            }
        });
        
        // Format as bullet lists
        Object.keys(archetypeGroups).forEach(archetype => {
            if (archetypeGroups[archetype].length > 0) {
                const facilityList = archetypeGroups[archetype]
                    .sort()
                    .map(facility => `â€¢ ${facility}`)
                    .join('<br>');
                archetypeDescriptions[archetype] = `Facilities include:<br>${facilityList}`;
            } else {
                archetypeDescriptions[archetype] = "No facilities listed for this archetype.";
            }
        });
        
        console.log('Archetype descriptions loaded successfully');
    } catch (error) {
        console.warn('Could not load archetype descriptions:', error);
        // Keep default loading messages if CSV fails to load
    }
}

// --- Data Loading & Processing ---
async function loadAndInitializeData() {
    showLoadingMessage("Loading baseline configuration...");
    try {
        const response = await fetch('input_configuration_snowflake_baseline_2023_2024.csv');
        if (!response.ok) throw new Error('Primary CSV not found, trying fallback.');
        const csvText = await response.text();
        processCSV(csvText, "Successfully loaded baseline data.");
    } catch (error) {
        console.warn(error.message);
        try {
            const fallbackResponse = await fetch('baseline.csv');
            if (!fallbackResponse.ok) throw new Error('Fallback CSV not found.');
            const csvText = await fallbackResponse.text();
            processCSV(csvText, "Successfully loaded baseline data from fallback.");
        } catch (fallbackError) {
            console.error("Could not auto-load any CSV:", fallbackError);
            app.innerHTML = '';
            fileUploadArea.classList.remove('hidden');
        }
    }
}
function loadCSVFile(file) {
  if (file && (file.type === "text/csv" || file.name.endsWith('.csv'))) {
    Papa.parse(file, {
      header: true, skipEmptyLines: true, dynamicTyping: true,
      complete: (results) => processCSV(results, `Successfully loaded ${file.name}.`),
      error: (err) => showMessage("Error reading the file.", "error")
    });
  } else {
    showMessage("Please select a valid .csv file.", "error");
  }
}
function processCSV(csvData, successMessage) {
    const results = (typeof csvData === 'string') ? Papa.parse(csvData, { header: true, skipEmptyLines: true, dynamicTyping: true }) : csvData;
    if (results.errors.length) {
        console.error("CSV Parsing Errors:", results.errors);
        return showMessage("Error parsing CSV file.", "error");
    }

    const descriptionRows = [];
    const mainDataRows = [];
    results.data.forEach(row => {
        if (row.scenario === 'Baseline Description' || row.scenario === 'Scenario Description') {
            descriptionRows.push(row);
        } else if (row.modality && row.archetype) {
            mainDataRows.push(row);
        }
    });
    
    const baselineDescRow = descriptionRows.find(r => r.scenario === 'Baseline Description');
    baselineDescription = baselineDescRow ? (baselineDescRow.baseyear || "") : "No baseline description found.";
    
    const scenarioDescRow = descriptionRows.find(r => r.scenario === 'Scenario Description');
    initialScenarioDescription = scenarioDescRow ? (scenarioDescRow.baseyear || "") : "";
    scenarioDescription = initialScenarioDescription;

    const processedData = mainDataRows.map(row => {
        const newRow = { ...row };
        projectionMetrics.forEach(metric => {
            newRow[metric] = {};
            years.forEach(yearKey => {
                newRow[metric][yearKey] = row[`${metric}_${yearKey}`];
                delete newRow[`${metric}_${yearKey}`];
            });
        });
        newRow.id = `${newRow.modality}-${newRow.archetype}`.replace(/\s+/g, '-').toLowerCase();
        return newRow;
    });

    const firstRow = processedData[0];
    if (firstRow) {
        if (firstRow.baseyear) {
            const parsedYear = parseInt(String(firstRow.baseyear).substring(0, 4), 10);
            if (!isNaN(parsedYear)) baseYearStart = parsedYear;
        }
        baselineName = firstRow.scenario || "Loaded Baseline Data";
    }

    baselineData = JSON.parse(JSON.stringify(processedData));
    scenarioData = JSON.parse(JSON.stringify(processedData));
    activeTabId = null; 
    scenarioName = "";
    
    fileUploadArea.classList.add('hidden');
    headerControlsWrapper.classList.remove('hidden');
    document.querySelector('.app-loading-message')?.classList.add('hidden');
    renderUI(baselineData, false);
    showMessage(successMessage, "success");
}

// --- UI Rendering ---
function renderUI(data, isEditable) {
  app.innerHTML = '';
  tabsNavContainer.innerHTML = '';
  
  scenarioNameCard.classList.toggle('hidden', !isEditable);
  baselineNameCard.classList.toggle('hidden', isEditable);
  // Keep hamburger menu visible in both baseline and scenario views
  actionsMenuContainer.classList.remove('hidden');
  
  if(isEditable) {
      scenarioNameInput.value = scenarioName;
      scenarioDescriptionInput.value = scenarioDescription;
  }
  baselineNameDisplay.textContent = baselineName;
  baselineDescriptionDisplay.textContent = baselineDescription;

  const groupedByModality = data.reduce((acc, row) => {
    (acc[row.modality] = acc[row.modality] || []).push(row);
    return acc;
  }, {});
  const modalities = Object.keys(groupedByModality).sort();
  if (!activeTabId || !modalities.some(m => `tab-${m.toLowerCase().replace(/\s/g, '-')}` === activeTabId)) {
     activeTabId = `tab-${modalities[0]?.toLowerCase().replace(/\s/g, '-')}`;
  }
  const nav = document.createElement('div');
  nav.className = 'tabs-nav';
  modalities.forEach(modality => {
    const displayName = modalityDisplayMap[modality] || modality;
    const tabId = `tab-${modality.toLowerCase().replace(/\s/g, '-')}`;
    const button = document.createElement('button');
    button.className = 'tab-button';
    button.classList.toggle('active', tabId === activeTabId);
    if (isEditable) {
      button.classList.toggle('has-changes', groupedByModality[modality].some(row => hasRowChanged(row.id)));
    }
    button.dataset.target = tabId;
    const iconName = modalityIcons[displayName];
    const iconHtml = iconName ? `<img src="../icons/${iconName}" class="tab-icon" alt="${displayName} icon">` : '';
    button.innerHTML = `${iconHtml}<span>${displayName}</span>`;
    nav.appendChild(button);
  });
  tabsNavContainer.appendChild(nav);
  modalities.forEach(modality => {
    const tabId = `tab-${modality.toLowerCase().replace(/\s/g, '-')}`;
    const panel = document.createElement('div');
    panel.id = tabId;
    panel.className = 'tab-panel';
    panel.classList.toggle('active', tabId === activeTabId);
    const activeSubTab = activeSubTabs['static-fields'];
    panel.dataset.staticFieldsSubtab = activeSubTab.replace(/\s/g, '-').replace('&', 'and');
    const archetypes = groupedByModality[modality].sort((a,b) => (archetypeSortOrder[a.archetype] || 99) - (archetypeSortOrder[b.archetype] || 99));
    panel.appendChild(createTableTitle('h3', 'Static Fields'));
    panel.appendChild(createSubNav('static-fields', Object.keys(staticFieldGroups), activeSubTab));
    panel.appendChild(createStaticTable(archetypes, isEditable));
    // Create projection grids container
    const projectionsContainer = document.createElement('div');
    projectionsContainer.className = 'projections-container';
    projectionMetrics.forEach(metric => {
        const titleWrapper = createTableTitle('div', projectionMetricLabels[metric], projectionMetricDescriptions[metric]);
        titleWrapper.classList.add('metric-title-wrapper');
        projectionsContainer.appendChild(titleWrapper);
        projectionsContainer.appendChild(createProjectionGrid(archetypes, metric, isEditable));
    });
    panel.appendChild(projectionsContainer);
    app.appendChild(panel);
  });
  updateHeaderButtonStates(isEditable);
}
function createSubNav(navId, groups, activeGroup) {
    const navContainer = document.createElement('div');
    navContainer.className = 'sub-nav-container';
    navContainer.dataset.navId = navId;
    groups.forEach(group => {
        const button = document.createElement('button');
        button.className = 'sub-nav-button';
        button.textContent = group;
        button.dataset.targetGroup = group;
        button.classList.toggle('active', group === activeGroup);
        navContainer.appendChild(button);
    });
    return navContainer;
}
function createTableTitle(tag, title, description) {
    const wrapper = document.createElement(tag);
    const titleEl = document.createElement(tag === 'div' ? 'h4' : 'span');
    titleEl.textContent = title;
    wrapper.appendChild(titleEl);
    if (description) {
        const infoContainer = document.createElement('div');
        infoContainer.className = 'info-container';
        const infoIcon = document.createElement('span');
        infoIcon.className = 'info-icon';
        infoIcon.textContent = '?';
        const tooltip = document.createElement('div');
        tooltip.className = 'info-tooltip';
        // Use innerHTML if description contains HTML tags, otherwise use textContent
        if (description.includes('<')) {
            tooltip.innerHTML = description;
        } else {
            tooltip.textContent = description;
        }
        infoContainer.appendChild(infoIcon);
        infoContainer.appendChild(tooltip);
        wrapper.appendChild(infoContainer);
    }
    return wrapper;
}
function createStaticTable(archetypes, isEditable) {
    const tableContainer = document.createElement('div');
    tableContainer.className = 'table-container';
    const table = document.createElement('table');
    table.className = 'data-table';
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const firstTh = document.createElement('th');
    firstTh.innerHTML = `<div class="th-content">Archetype</div>`;
    headerRow.appendChild(firstTh);
    staticFields.forEach(f => {
        const th = document.createElement('th');
        const groupName = Object.keys(staticFieldGroups).find(group => staticFieldGroups[group].includes(f));
        th.dataset.group = groupName.replace(/\s/g, '-').replace('&', 'and');
        const contentDiv = document.createElement('div');
        contentDiv.className = 'th-content';
        contentDiv.textContent = staticFieldLabels[f];
        const infoContainer = createTableTitle('div', '', staticFieldDescriptions[f]).querySelector('.info-container');
        if(infoContainer) contentDiv.appendChild(infoContainer);
        th.appendChild(contentDiv);
        headerRow.appendChild(th);
    });
    const tbody = table.createTBody();
    archetypes.forEach(row => {
        const tr = tbody.insertRow();
        const archetypeCell = tr.insertCell();
        const labelWrapper = document.createElement('div');
        labelWrapper.className = 'archetype-label-wrapper';
        const labelSpan = document.createElement('span');
        labelSpan.textContent = row.archetype;
        labelWrapper.appendChild(labelSpan);
        const description = archetypeDescriptions[row.archetype] || archetypeDescriptions["Default"];
        const infoContainer = createTableTitle('div', '', description).querySelector('.info-container');
        if (infoContainer) {
            infoContainer.querySelector('.info-tooltip').classList.add('tooltip-right');
            labelWrapper.appendChild(infoContainer);
        }
        archetypeCell.appendChild(labelWrapper);
        staticFields.forEach(field => {
            const td = tr.insertCell();
            const groupName = Object.keys(staticFieldGroups).find(group => staticFieldGroups[group].includes(field));
            td.dataset.group = groupName.replace(/\s/g, '-').replace('&', 'and');
            const config = staticFieldSliderConfig[field];
            if (!config) return;
            const wrapper = document.createElement('div');
            wrapper.className = 'input-slider-wrapper';
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'static-field-input';
            const value = row[field];
            input.value = (value !== null && typeof value !== 'undefined' && !isNaN(value)) ? config.format(value) : 'N/A';
            input.dataset.id = row.id;
            input.dataset.field = field;
            input.readOnly = !isEditable;
            wrapper.appendChild(input);
            if (isEditable) {
                const baselineRow = baselineData.find(br => br.id === row.id);
                if (baselineRow && Math.abs(parseFloat(value) - parseFloat(baselineRow[field])) > 1e-9) {
                    td.classList.add('changed');
                }
                const sliderContainer = document.createElement('div');
                sliderContainer.className = 'slider-container';
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = config.min; slider.max = config.max; slider.step = config.step;
                slider.value = value;
                sliderContainer.appendChild(slider);
                wrapper.appendChild(sliderContainer);
            }
            td.appendChild(wrapper);
        });
    });
    tableContainer.appendChild(table);
    return tableContainer;
}
function createProjectionGrid(archetypes, metric, isEditable) {
    const grid = document.createElement('div');
    grid.className = 'projection-grid';
    archetypes.forEach(row => {
        const archetypeRow = document.createElement('div');
        archetypeRow.className = 'projection-archetype-row';
        const archetypeLabel = document.createElement('div');
        archetypeLabel.className = 'projection-archetype-label';
        archetypeLabel.textContent = row.archetype;
        archetypeRow.appendChild(archetypeLabel);
        const yearGrid = document.createElement('div');
        yearGrid.className = 'year-inputs-grid';
        years.forEach((yearKey, index) => {
            const item = document.createElement('div');
            item.className = 'year-input-item';
            const label = document.createElement('label');
            label.textContent = `FY ${String(baseYearStart + index).slice(-2)}/${String(baseYearStart + index + 1).slice(-2)}`;
            const input = document.createElement('input');
            input.type = 'text';
            const config = projectionMetricConfig[metric];
            const value = row[metric]?.[yearKey];
            if (value !== null && typeof value !== 'undefined' && !isNaN(value)) {
                input.value = config ? config.format(value) : value.toFixed(2);
            } else {
                input.value = 'N/A';
            }
            input.dataset.id = row.id;
            input.dataset.field = `${metric}.${yearKey}`;
            input.readOnly = !isEditable || yearKey === 'y0';
            const baselineRow = baselineData.find(br => br.id === row.id);
            if (isEditable && baselineRow && Math.abs(parseFloat(baselineRow[metric]?.[yearKey]) - parseFloat(value)) > 1e-9) {
                input.classList.add('changed');
            }
            item.appendChild(label);
            item.appendChild(input);
            yearGrid.appendChild(item);
        });
        archetypeRow.appendChild(yearGrid);
        grid.appendChild(archetypeRow);
    });
    return grid;
}

// --- Event Handling & Data Manipulation ---
function handleDataInput(e) {
    const slider = e.target;
    if (slider.type !== 'range') return;
    const textInput = slider.closest('.input-slider-wrapper').querySelector('input[type=text]');
    const { id: rowId, field: fieldKey } = textInput.dataset;
    const config = staticFieldSliderConfig[fieldKey];
    const rowToUpdate = scenarioData.find(row => row.id === rowId);
    if (!rowToUpdate || !config) return;
    const newValue = parseFloat(slider.value);
    textInput.value = config.format(newValue);
    rowToUpdate[fieldKey] = newValue;
    updateChangeState(rowId, fieldKey);
}
function handleDataChange(e) {
    const textInput = e.target;
    if (textInput.type !== 'text' || !textInput.dataset.id) return;
    const { id: rowId, field: fieldKey } = textInput.dataset;
    const rowToUpdate = scenarioData.find(row => row.id === rowId);
    if (!rowToUpdate) return;
    if (staticFields.includes(fieldKey)) {
        const config = staticFieldSliderConfig[fieldKey];
        if (!config) return;
        let parsedValue = config.parse(textInput.value);
        const originalValue = rowToUpdate[fieldKey];
        if (isNaN(parsedValue)) {
            return textInput.value = (originalValue !== null && !isNaN(originalValue)) ? config.format(originalValue) : 'N/A';
        }
        const clampedValue = Math.max(config.min, Math.min(config.max, parsedValue));
        rowToUpdate[fieldKey] = clampedValue;
        textInput.value = config.format(clampedValue);
        const slider = textInput.closest('.input-slider-wrapper').querySelector('input[type=range]');
        if (slider) slider.value = clampedValue;
        updateChangeState(rowId, fieldKey);
    } 
    else {
        const [metric, yearKey] = fieldKey.split('.');
        const config = projectionMetricConfig[metric];
        const originalValue = rowToUpdate[metric]?.[yearKey];
        let numericValue;
        if (config) {
            numericValue = config.parse(textInput.value);
            if (isNaN(numericValue) || numericValue < config.min || numericValue > config.max) {
                showMessage(`Invalid input. Please enter a percentage between ${config.format(config.min)} and ${config.format(config.max)}.`, 'error');
                textInput.value = (originalValue !== null && !isNaN(originalValue)) ? config.format(originalValue) : 'N/A';
                return;
            }
            rowToUpdate[metric][yearKey] = numericValue;
            textInput.value = config.format(numericValue);
        } else {
            numericValue = parseFloat(textInput.value);
            if (isNaN(numericValue)) {
                textInput.value = (originalValue !== null && !isNaN(originalValue)) ? originalValue.toFixed(2) : 'N/A';
                return;
            }
            rowToUpdate[metric][yearKey] = numericValue;
            textInput.value = numericValue.toFixed(2);
        }
        updateChangeState(rowId, fieldKey);
        const yearIndex = years.indexOf(yearKey);
        if (yearIndex < years.length - 1) {
            currentProjectionChangeContext = {
                numericValue,
                metric,
                archetype: rowToUpdate.archetype,
                yearKey,
                yearIndex,
            };
            showProjectionModal();
        }
    }
}
function updateChangeState(rowId, fieldKey) {
    const rowToUpdate = scenarioData.find(row => row.id === rowId);
    const baselineRow = baselineData.find(row => row.id === rowId);
    const inputElement = document.querySelector(`input[data-id="${rowId}"][data-field="${fieldKey}"]`);
    if (!inputElement || !baselineRow) return;
    const cell = inputElement.closest('td, .year-input-item');
    let isChanged = false;
    if (staticFields.includes(fieldKey)) {
        isChanged = Math.abs(parseFloat(rowToUpdate[fieldKey]) - parseFloat(baselineRow[fieldKey])) > 1e-9;
    } else {
        const [metric, yearKey] = fieldKey.split('.');
        isChanged = Math.abs(parseFloat(rowToUpdate[metric]?.[yearKey]) - parseFloat(baselineRow[metric]?.[yearKey])) > 1e-9;
    }
    if (cell.matches('td')) {
        cell.classList.toggle('changed', isChanged);
    } else {
        inputElement.classList.toggle('changed', isChanged);
    }
    const modality = rowToUpdate.modality;
    const tabButton = document.querySelector(`.tab-button[data-target="tab-${modality.toLowerCase().replace(/\s/g, '-')}"]`);
    if (tabButton) {
        tabButton.classList.toggle('has-changes', scenarioData.filter(r => r.modality === modality).some(r => hasRowChanged(r.id)));
    }
    updateHeaderButtonStates(true);
}
function hasRowChanged(rowId) {
    const scenarioRow = scenarioData.find(r => r.id === rowId);
    const baselineRow = baselineData.find(r => r.id === rowId);
    if (!scenarioRow || !baselineRow) return false;
    return staticFields.some(key => Math.abs(parseFloat(scenarioRow[key]) - parseFloat(baselineRow[key])) > 1e-9) || 
           projectionMetrics.some(metric => years.some(yearKey => Math.abs(parseFloat(scenarioRow[metric]?.[yearKey]) - parseFloat(baselineRow[metric]?.[yearKey])) > 1e-9));
}

// --- Import/Export/Save Functions ---
function exportScenarioCSV() {
    actionsDropdownMenu.classList.add('hidden');
    setTimeout(() => { 
        const flatData = scenarioData.map(row => {
            const newFlatRow = { ...row };
            projectionMetrics.forEach(metric => {
                if (newFlatRow[metric]) {
                    years.forEach(yearKey => {
                        newFlatRow[`${metric}_${yearKey}`] = newFlatRow[metric][yearKey];
                    });
                    delete newFlatRow[metric];
                }
            });
            delete newFlatRow.id;
            return newFlatRow;
        });

        const headers = Object.keys(flatData[0] || {});
        const emptyRow = headers.reduce((acc, header) => ({...acc, [header]: ''}), {});
        const baselineDescRowForExport = { ...emptyRow, scenario: 'Baseline Description', baseyear: baselineDescription };
        const scenarioDescRowForExport = { ...emptyRow, scenario: 'Scenario Description', baseyear: scenarioDescription };

        for (let i = 0; i < 21; i++) { 
            flatData.push({ ...emptyRow });
        }
        flatData.push(baselineDescRowForExport);
        flatData.push(scenarioDescRowForExport);

        const csv = Papa.unparse(flatData);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        
        const scenarioNameSlug = (scenarioName.trim() || 'untitled').replace(/\s+/g, '_');
        const exportDate = new Date().toISOString().slice(0, 10);
        const filename = `input_configuration_snowflake_scenario_${scenarioNameSlug}_${exportDate}.csv`;
        
        link.setAttribute("download", filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showMessage("CSV exported successfully!", "success");
    }, 500);
}

function saveDraft() {
    actionsDropdownMenu.classList.add('hidden');
    const draft = {
        scenarioName,
        scenarioDescription,
        scenarioData
    };
    const draftString = JSON.stringify(draft, null, 2);
    const blob = new Blob([draftString], { type: 'application/json;charset=utf-8;' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    const filename = (scenarioName.trim().replace(/\s+/g, '_') || 'scenario_draft') + `_${new Date().toISOString().slice(0,10)}.lora-draft`;
    link.setAttribute("download", filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    showMessage("Draft saved successfully!", "success");
}

function loadDraft(file) {
    if (!file || !(file.name.endsWith('.lora-draft') || file.name.endsWith('.json'))) {
        return showMessage("Please select a valid .lora-draft file.", "error");
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const draft = JSON.parse(e.target.result);
            if (!draft.scenarioData || !('scenarioName' in draft) || !('scenarioDescription' in draft)) {
                throw new Error("Invalid draft file format.");
            }
            scenarioName = draft.scenarioName;
            scenarioDescription = draft.scenarioDescription;
            scenarioData = draft.scenarioData;
            
            importDraftModalOverlay.classList.add('hidden');
            renderUI(scenarioData, true);
            showMessage(`Successfully loaded draft: ${file.name}.`, "success");
        } catch (error) {
            console.error("Error parsing draft file:", error);
            showMessage("Could not read draft file. It may be corrupted.", "error");
        }
    };
    reader.onerror = () => showMessage("Error reading the file.", "error");
    reader.readAsText(file);
}

// --- Helper Functions ---
function updateHeaderButtonStates(isEditable) {
    // Keep hamburger menu visible in both baseline and scenario views
    actionsMenuContainer.classList.remove('hidden');

    if (!isEditable) {
        // In baseline view, only show Import Draft option
        menuSaveDraft.classList.add('hidden');
        menuExport.classList.add('hidden');
        menuReset.classList.add('hidden');
        menuDivider.classList.add('hidden');
        menuImportDraft.classList.remove('hidden');
    } else {
        // In scenario view, show/hide based on changes
        const hasDataChanges = scenarioData.some(row => hasRowChanged(row.id));
        const hasDescriptionChange = scenarioDescription !== initialScenarioDescription;
        const hasChanges = hasDataChanges || hasDescriptionChange;

        menuSaveDraft.classList.toggle('hidden', !hasChanges);
        menuExport.classList.toggle('hidden', !hasChanges);
        menuReset.classList.toggle('hidden', !hasChanges);
        menuDivider.classList.toggle('hidden', !hasChanges);
        menuImportDraft.classList.remove('hidden');
    }
}
function hideAllSliders() {
    document.querySelectorAll('.slider-container.visible').forEach(slider => slider.classList.remove('visible'));
}
function showLoadingMessage(message) {
    app.innerHTML = `<div class="app-loading-message">${message}</div>`;
}
function showMessage(message, type = 'success') {
    const statusMessage = document.getElementById('status-message');
    const p = document.createElement('p');
    p.className = type;
    p.textContent = message;
    statusMessage.innerHTML = '';
    statusMessage.appendChild(p);
    setTimeout(() => { statusMessage.innerHTML = ''; }, 3000);
}

// --- Modal Functions ---
function showInfoModal() {
    infoModalOverlay.classList.remove('hidden');
}
function hideInfoModal() {
    infoModalOverlay.classList.add('hidden');
}
function showResetModal() {
    actionsDropdownMenu.classList.add('hidden');
    resetModalOverlay.classList.remove('hidden');
}
function hideResetModal() {
    resetModalOverlay.classList.add('hidden');
}
function handleResetConfirm() {
    scenarioData = JSON.parse(JSON.stringify(baselineData));
    scenarioName = ""; 
    scenarioDescription = initialScenarioDescription;
    hideResetModal();
    renderUI(scenarioData, true); 
    showMessage("Scenario has been reset to baseline values.", "success");
}
function showProjectionModal() {
    toggleSubsequentYears.checked = true;
    toggleAllModalities.checked = false;
    projectionModalOverlay.classList.remove('hidden');
}
function hideProjectionModal() {
    projectionModalOverlay.classList.add('hidden');
    currentProjectionChangeContext = null;
}
function handleProjectionConfirm() {
    if (!currentProjectionChangeContext) return;
    const { numericValue, metric, archetype, yearIndex } = currentProjectionChangeContext;
    const applyToSubsequent = toggleSubsequentYears.checked;
    const applyToAllModalities = toggleAllModalities.checked;
    const config = projectionMetricConfig[metric];
    const processRow = (row, startYearIndex) => {
        if (applyToSubsequent) {
            for (let i = startYearIndex + 1; i < years.length; i++) {
                const subsequentYearKey = years[i];
                row[metric][subsequentYearKey] = numericValue;
                const inputElement = document.querySelector(`input[data-id="${row.id}"][data-field="${metric}.${subsequentYearKey}"]`);
                if (inputElement) {
                    inputElement.value = config ? config.format(numericValue) : numericValue.toFixed(2);
                    updateChangeState(row.id, `${metric}.${subsequentYearKey}`);
                }
            }
        }
    };
    if (applyToAllModalities) {
        scenarioData.forEach(row => {
            if (row.archetype === archetype) {
                const initialYearKey = years[yearIndex];
                if (row[metric][initialYearKey] !== numericValue) {
                   row[metric][initialYearKey] = numericValue;
                   const inputElement = document.querySelector(`input[data-id="${row.id}"][data-field="${metric}.${initialYearKey}"]`);
                    if (inputElement) {
                        inputElement.value = config ? config.format(numericValue) : numericValue.toFixed(2);
                        updateChangeState(row.id, `${metric}.${initialYearKey}`);
                    }
                }
                processRow(row, yearIndex);
            }
        });
    } else {
        const originalModalityTab = document.querySelector('.tab-button.active');
        if (!originalModalityTab) return;
        const originalModalityName = originalModalityTab.dataset.target.replace('tab-','').toUpperCase();
        const originalRow = scenarioData.find(row => row.archetype === archetype && (row.modality === originalModalityName || (modalityDisplayMap[row.modality] === originalModalityName.toUpperCase())));
        if(originalRow) processRow(originalRow, yearIndex);
    }
    hideProjectionModal();
}
</script>
</body>
</html>
