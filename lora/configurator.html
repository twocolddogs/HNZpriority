<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LORA Scenario Configurator</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="rtt-container">
    <header class="rtt-sticky-header">
      <div class="rtt-brand-bar">
        <img src="../images/HealthNZ_logo_v2.svg" alt="Health NZ Logo" class="rtt-app-logo">
        <div class="rtt-header-divider"></div>
        <h1 class="rtt-title">LORA Scenario Configurator</h1>
        <div class="rtt-flex-spacer"></div>
        <div id="header-controls-wrapper" class="hidden">
          <div class="rtt-header-controls">
            <div class="scenario-controls" id="scenario-toggle">
              <input type="radio" id="source-baseline" name="data-source" value="baseline" checked>
              <label for="source-baseline">Baseline</label>
              <input type="radio" id="source-scenario" name="data-source" value="scenario">
              <label for="source-scenario">Scenario</label>
              <span class="scenario-switch-bg" aria-hidden="true"></span>
            </div>
            <button id="export-button" class="rtt-download-btn">
              <span id="export-spinner" class="loading-spinner hidden"></span>
              Export CSV
            </button>
          </div>
        </div>
      </div>
    </header>

    <main id="main-content">
       <div id="baseline-name-card" class="name-card hidden">
        <div class="name-card-header"><h2>Baseline Name</h2></div>
        <div class="name-card-content">
          <p id="baseline-name-display">Default Baseline</p>
        </div>
      </div>
      <div id="scenario-name-card" class="name-card hidden">
        <div class="name-card-header"><h2>Scenario Name</h2></div>
        <div class="name-card-content">
          <label for="scenario-name-input">Enter a name for your scenario:</label>
          <input type="text" id="scenario-name-input" placeholder="e.g., High Growth Projection">
        </div>
      </div>
      
      <div id="sticky-tabs-wrapper">
        <div id="tabs-nav-container"></div>
      </div>

      <div id="file-upload-area" class="file-upload hidden">
        <h3>Load Configuration Data</h3>
        <p>Drag & drop your CSV file here, or click to select.</p>
        <div class="file-input">
          <input type="file" id="csv-file-input" accept=".csv" />
          <label for="csv-file-input">Choose File</label>
        </div>
      </div>
      
      <div id="app">
        <div class="app-loading-message">Loading Configuration...</div>
      </div>
    </main>
    
    <div id="status-message" class="status-message"></div>
    <div id="global-tooltip" class="global-tooltip"></div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script>
    // --- Data Definitions ---
const staticFields = ["non_demographic_growth", "routine_machine_hours", "share_of_scans_during_day", "ooh_machines", "ras_per_routine_machine_hour", "mit_shift_length", "mit_weeks_lost", "session_length_hours", "clinical_reporting_sessions_per_rad", "rad_weeks_lost"];
const staticFieldLabels = { "non_demographic_growth": "Non-Demographic Growth", "routine_machine_hours": "Routine Machine Hours", "share_of_scans_during_day": "Share of Scans During Day", "ooh_machines": "OOH Machines", "ras_per_routine_machine_hour": "RAs per Routine Hour", "mit_shift_length": "MIT Shift Length", "mit_weeks_lost": "MIT Weeks Lost", "session_length_hours": "Session Length (Hrs)", "clinical_reporting_sessions_per_rad": "Rad Reporting Sessions", "rad_weeks_lost": "Rad Weeks Lost" };
const staticFieldDescriptions = { "non_demographic_growth": "Non-demographic growth is a % change to apply over and above demographic growth (which comes from population projections). This varies by Modality.", "routine_machine_hours": "Routine machine hours provides the number of hours one machine of that modality would be expected to run in a normal working week.", "share_of_scans_during_day": "This is the % of events that occurred during routine hours which sets the level of activity to meet in hours.", "ooh_machines": "This is the number of machines each archetype is expected to run out of hours (OOH).", "ras_per_routine_machine_hour": "Radiology Assistants (RAs) support efficient delivery of CT and MR modalities. This ratio provides the number of RAs needed per routine machine hour.", "mit_shift_length": "MITs run the modalities and so to identify their FTE requirements we need to set the shift length they will work. This is strictly 4 hours.", "mit_weeks_lost": "This is a factor to account for cover given the need for MITs to take leave.", "session_length_hours": "This is the length of a session that a radiologist reports on an event, this tends to be 4 hours.", "clinical_reporting_sessions_per_rad": "This provides the number of reporting sessions that each radiologist does per week - this varies by archetype as larger facilities have a broader set of responsibilities for radiologists.", "rad_weeks_lost": "This is a factor to account for cover given the need for radiologists to take leave." };
const staticFieldSliderConfig = { non_demographic_growth: { min: -0.05, max: 0.1, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s.replace('%','')) / 100 }, routine_machine_hours: { min: 40, max: 84, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, share_of_scans_during_day: { min: 0.90, max: 1.00, step: 0.001, format: v => `${(parseFloat(v) * 100).toFixed(1)}%`, parse: s => parseFloat(s.replace('%','')) / 100 }, ooh_machines: { min: 0, max: 4, step: 1, format: v => Math.round(v), parse: s => parseFloat(s) }, ras_per_routine_machine_hour: { min: 0, max: 2, step: 0.1, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, mit_shift_length: { min: 4, max: 6, step: 1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, mit_weeks_lost: { min: 6, max: 8, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, session_length_hours: { min: 4, max: 5, step: 0.5, format: v => parseFloat(v).toFixed(2), parse: s => parseFloat(s) }, clinical_reporting_sessions_per_rad: { min: 2, max: 10, step: 0.5, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, rad_weeks_lost: { min: 10, max: 14, step: 0.1, format: v => parseFloat(v).toFixed(1), parse: s => parseFloat(s) }, };

const staticFieldGroups = {
    'Demand & Machine Assumptions': ['non_demographic_growth', 'routine_machine_hours', 'share_of_scans_during_day', 'ooh_machines'],
    'Workforce': ['ras_per_routine_machine_hour', 'mit_shift_length', 'mit_weeks_lost', 'session_length_hours', 'clinical_reporting_sessions_per_rad', 'rad_weeks_lost']
};

const projectionMetrics = ["ip_volume_step", "op_volume_step", "scan_rate", "report_rate", "mits_per_routine_machine_hour", "mits_per_ooh_machine_hour"];
const projectionMetricLabels = { "ip_volume_step": "Inpatient Volume Step Change", "op_volume_step": "Outpatient Volume Step Change", "scan_rate": "Scan Rate (Mins)", "report_rate": "Report Rate (Mins)", "mits_per_routine_machine_hour": "MITs per Routine Machine Hour", "mits_per_ooh_machine_hour": "MITs per OOH Machine Hour" };
const projectionMetricDescriptions = { "ip_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "op_volume_step": "These financial-year-based 10 fields provide a % change based step ED/Inpatient uplift in activity which may be required when testing scenarios, e.g., impact of lung screening. These vary by modality and archetype.", "scan_rate": "These financial-year-based 10 fields provide the number of minutes required for modality to be scanning per event, which may change over time as technologies change. These vary by modality and archetype.", "report_rate": "These financial-year-based 10 fields provide the number of minutes required for a radiologist to report on an event, which may change over time as technologies change. These vary by modality and archetype", "mits_per_routine_machine_hour": "These financial-year-based 10 fields provide the number of MITs required in-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype.", "mits_per_ooh_machine_hour": "These financial-year-based 10 fields provide the number of MITs required out-of-hours per machine hour to run the machines, which may change over time as technologies change. These vary by modality and archetype." };

const modalityDisplayMap = { "MR": "MRI" };
const modalityIcons = { "CT": "CT.png", "US": "US.png", "XR": "XR.png", "MRI": "MRI.png" };

const archetypeDescriptions = {
    "X Small": "Facilities include: Patea Health Centre, Opunake Health Centre, Waiouru Military Camp.",
    "Small": "Facilities include: Wairoa Hospital, Taumarunui Hospital, Dannevirke Community Hospital, Hawera Hospital.",
    "Medium": "Facilities include: Whanganui Hospital, Gisborne Hospital, Wairau Hospital (Blenheim), Timaru Hospital.",
    "Large": "Facilities include: Tauranga Hospital, Palmerston North Hospital, Dunedin Hospital, Wellington Regional Hospital.",
    "X Large": "Facilities include: Auckland City Hospital, Christchurch Hospital, Waikato Hospital, Middlemore Hospital.",
    "Default": "No facility list available for this archetype."
};

const years = Array.from({ length: 11 }, (_, i) => `y${i}`);
let baseYearStart = new Date().getFullYear(); 
const archetypeSortOrder = { "X Small": 1, "Small": 2, "Medium": 3, "Large": 4, "X Large": 5, };

// --- DOM Element Cache ---
const app = document.getElementById("app");
const mainContent = document.getElementById("main-content");
const headerControlsWrapper = document.getElementById("header-controls-wrapper");
const scenarioToggle = document.getElementById("scenario-toggle");
const exportButton = document.getElementById("export-button");
const fileUploadArea = document.getElementById("file-upload-area");
const scenarioNameCard = document.getElementById("scenario-name-card");
const scenarioNameInput = document.getElementById("scenario-name-input");
const baselineNameCard = document.getElementById("baseline-name-card");
const baselineNameDisplay = document.getElementById("baseline-name-display");
const tabsNavContainer = document.getElementById("tabs-nav-container");
const globalTooltip = document.getElementById("global-tooltip");

// --- State Variables ---
let baselineData = [], scenarioData = [];
let activeTabId = null, scenarioName = "", baselineName = "Default Baseline";
let activeSubTabs = { 'static-fields': 'Demand & Machine Assumptions' };

// --- Simplified Tooltip System ---
function showTooltip(triggerElement, content) {
    hideTooltip();
    
    const rect = triggerElement.getBoundingClientRect();
    globalTooltip.innerHTML = content;
    globalTooltip.style.display = 'block';
    
    // Get tooltip dimensions after content is set
    const tooltipRect = globalTooltip.getBoundingClientRect();
    
    // Check if this is an archetype tooltip (in first column)
    const isArchetype = triggerElement.closest('.archetype-label-wrapper') !== null;
    
    let top, left;
    
    if (isArchetype) {
        // Position to the right of the trigger
        top = rect.top + window.scrollY + (rect.height / 2) - (tooltipRect.height / 2);
        left = rect.right + window.scrollX + 12;
        
        // If tooltip would go off screen on the right, position it to the left
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = rect.left + window.scrollX - tooltipRect.width - 12;
        }
    } else {
        // Position below the trigger (normal tooltips)
        top = rect.bottom + window.scrollY + 8;
        left = rect.left + window.scrollX + (rect.width / 2) - (tooltipRect.width / 2);
        
        // Keep tooltip on screen horizontally
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
    }
    
    // Keep tooltip on screen vertically
    if (top < 10) top = 10;
    if (top + tooltipRect.height > window.innerHeight + window.scrollY - 10) {
        top = window.innerHeight + window.scrollY - tooltipRect.height - 10;
    }
    
    globalTooltip.style.top = `${top}px`;
    globalTooltip.style.left = `${left}px`;
    globalTooltip.classList.add('visible');
    
    // Mark trigger as active
    triggerElement.classList.add('active');
}

function hideTooltip() {
    globalTooltip.classList.remove('visible');
    globalTooltip.style.display = 'none';
    document.querySelectorAll('.info-icon.active').forEach(icon => {
        icon.classList.remove('active');
    });
}

// --- Initial Setup ---
document.addEventListener('DOMContentLoaded', () => {
    loadAndInitializeData();
    setupEventListeners();
});

// --- Event Listeners Setup ---
function setupEventListeners() {
  scenarioToggle.addEventListener('change', (e) => {
    const isBaseline = e.target.value === 'baseline';
    renderUI(isBaseline ? baselineData : scenarioData, !isBaseline);
  });

  document.getElementById('csv-file-input').addEventListener('change', (e) => loadCSVFile(e.target.files[0]));
  scenarioNameInput.addEventListener('input', (e) => { scenarioName = e.target.value; });
  exportButton.addEventListener('click', exportScenarioCSV);
  
  tabsNavContainer.addEventListener('click', (e) => {
    const button = e.target.closest('.tab-button');
    if (!button) return;
    activeTabId = button.dataset.target;
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.toggle('active', btn === button));
    document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.toggle('active', panel.id === activeTabId));
  });
  
  app.addEventListener('click', (e) => {
    const subNavButton = e.target.closest('.sub-nav-button');
    if (subNavButton) {
        const navId = subNavButton.parentElement.dataset.navId;
        const targetGroup = subNavButton.dataset.targetGroup;
        activeSubTabs[navId] = targetGroup;
        
        const tabPanel = subNavButton.closest('.tab-panel');
        tabPanel.dataset.staticFieldsSubtab = targetGroup.replace(/\s/g, '-').replace('&', 'and');

        subNavButton.parentElement.querySelectorAll('.sub-nav-button').forEach(btn => {
            btn.classList.toggle('active', btn === subNavButton);
        });
    }
  });
  
  // Simplified click handling for tooltips
  document.addEventListener('click', (e) => {
    const infoIcon = e.target.closest('.info-icon');
    
    if (infoIcon) {
        e.stopPropagation();
        
        // Check if this tooltip is already visible
        const isCurrentlyActive = infoIcon.classList.contains('active');
        
        if (isCurrentlyActive) {
            hideTooltip();
        } else {
            // Find the hidden tooltip content
            const hiddenTooltip = infoIcon.nextElementSibling;
            if (hiddenTooltip && hiddenTooltip.classList.contains('info-tooltip')) {
                showTooltip(infoIcon, hiddenTooltip.innerHTML);
            }
        }
    } else {
        // Click outside - hide tooltip
        hideTooltip();
    }
    
    // Hide sliders when clicking outside
    if (!e.target.closest('.input-slider-wrapper')) {
        hideAllSliders();
    }
  });

  app.addEventListener('focusin', (e) => {
    if (e.target.matches('.static-field-input')) {
        hideAllSliders();
        const wrapper = e.target.closest('.input-slider-wrapper');
        if (wrapper) wrapper.querySelector('.slider-container')?.classList.add('visible');
    }
  });
  
  app.addEventListener('input', handleDataInput);
  app.addEventListener('change', handleDataChange);
}

// --- Data Loading & Processing ---
async function loadAndInitializeData() {
    showLoadingMessage("Loading baseline configuration...");
    try {
        const response = await fetch('input_configuration_snowflake_baseline_2023_2024.csv');
        if (!response.ok) throw new Error('Primary CSV not found, trying fallback.');
        const csvText = await response.text();
        processCSV(csvText, "Successfully loaded baseline data.");
    } catch (error) {
        console.warn(error.message);
        try {
            const fallbackResponse = await fetch('baseline.csv');
            if (!fallbackResponse.ok) throw new Error('Fallback CSV not found.');
            const csvText = await fallbackResponse.text();
            processCSV(csvText, "Successfully loaded baseline data from fallback.");
        } catch (fallbackError) {
            console.error("Could not auto-load any CSV:", fallbackError);
            app.innerHTML = '';
            fileUploadArea.classList.remove('hidden');
        }
    }
}

function loadCSVFile(file) {
  if (file && (file.type === "text/csv" || file.name.endsWith('.csv'))) {
    Papa.parse(file, {
      header: true, skipEmptyLines: true, dynamicTyping: true,
      complete: (results) => processCSV(results, `Successfully loaded ${file.name}.`),
      error: (err) => showMessage("Error reading the file.", "error")
    });
  } else {
    showMessage("Please select a valid .csv file.", "error");
  }
}

function processCSV(csvData, successMessage) {
    const results = (typeof csvData === 'string') ? Papa.parse(csvData, { header: true, skipEmptyLines: true, dynamicTyping: true }) : csvData;

    if (results.errors.length) {
        console.error("CSV Parsing Errors:", results.errors);
        return showMessage("Error parsing CSV file.", "error");
    }

    const processedData = results.data.map(row => {
        const newRow = { ...row };
        projectionMetrics.forEach(metric => {
            newRow[metric] = {};
            years.forEach(yearKey => {
                newRow[metric][yearKey] = row[`${metric}_${yearKey}`];
                delete newRow[`${metric}_${yearKey}`];
            });
        });
        newRow.id = `${newRow.modality}-${newRow.archetype}`.replace(/\s+/g, '-').toLowerCase();
        return newRow;
    });

    const firstRow = processedData[0];
    if (firstRow) {
        if (firstRow.baseyear) {
            const parsedYear = parseInt(String(firstRow.baseyear).substring(0, 4), 10);
            if (!isNaN(parsedYear)) baseYearStart = parsedYear;
        }
        baselineName = firstRow.scenario || "Loaded Baseline Data";
    }

    baselineData = JSON.parse(JSON.stringify(processedData));
    scenarioData = JSON.parse(JSON.stringify(processedData));
    activeTabId = null; scenarioName = "";

    fileUploadArea.classList.add('hidden');
    headerControlsWrapper.classList.remove('hidden');
    document.querySelector('.app-loading-message')?.classList.add('hidden');
    
    renderUI(baselineData, false);
    showMessage(successMessage, "success");
}

// --- UI Rendering ---
function renderUI(data, isEditable) {
  app.innerHTML = '';
  tabsNavContainer.innerHTML = '';
  scenarioNameCard.classList.toggle('hidden', !isEditable);
  baselineNameCard.classList.toggle('hidden', isEditable);
  if(isEditable) scenarioNameInput.value = scenarioName;
  baselineNameDisplay.textContent = baselineName;

  const groupedByModality = data.reduce((acc, row) => {
    (acc[row.modality] = acc[row.modality] || []).push(row);
    return acc;
  }, {});
  
  const modalities = Object.keys(groupedByModality).sort();
  if (!activeTabId || !modalities.some(m => `tab-${m.toLowerCase().replace(/\s/g, '-')}` === activeTabId)) {
     activeTabId = `tab-${modalities[0]?.toLowerCase().replace(/\s/g, '-')}`;
  }

  const nav = document.createElement('div');
  nav.className = 'tabs-nav';
  modalities.forEach(modality => {
    const displayName = modalityDisplayMap[modality] || modality;
    const tabId = `tab-${modality.toLowerCase().replace(/\s/g, '-')}`;
    const button = document.createElement('button');
    button.className = 'tab-button';
    button.classList.toggle('active', tabId === activeTabId);
    if (isEditable) {
      button.classList.toggle('has-changes', groupedByModality[modality].some(row => hasRowChanged(row.id)));
    }
    button.dataset.target = tabId;
    const iconName = modalityIcons[displayName];
    const iconHtml = iconName ? `<img src="../icons/${iconName}" class="tab-icon" alt="${displayName} icon">` : '';
    button.innerHTML = `${iconHtml}<span>${displayName}</span>`;
    nav.appendChild(button);
  });
  tabsNavContainer.appendChild(nav);
  
  modalities.forEach(modality => {
    const tabId = `tab-${modality.toLowerCase().replace(/\s/g, '-')}`;
    const panel = document.createElement('div');
    panel.id = tabId;
    panel.className = 'tab-panel';
    panel.classList.toggle('active', tabId === activeTabId);
    const activeSubTab = activeSubTabs['static-fields'];
    panel.dataset.staticFieldsSubtab = activeSubTab.replace(/\s/g, '-').replace('&', 'and');
    
    const archetypes = groupedByModality[modality].sort((a,b) => (archetypeSortOrder[a.archetype] || 99) - (archetypeSortOrder[b.archetype] || 99));

    panel.appendChild(createTableTitle('h3', 'Static Fields'));
    panel.appendChild(createSubNav('static-fields', Object.keys(staticFieldGroups), activeSubTab));
    panel.appendChild(createStaticTable(archetypes, isEditable));

    projectionMetrics.forEach(metric => {
        const titleWrapper = createTableTitle('div', projectionMetricLabels[metric], projectionMetricDescriptions[metric]);
        titleWrapper.classList.add('metric-title-wrapper');
        panel.appendChild(titleWrapper);
        panel.appendChild(createProjectionGrid(archetypes, metric, isEditable));
    });
    
    app.appendChild(panel);
  });
}

function createSubNav(navId, groups, activeGroup) {
    const navContainer = document.createElement('div');
    navContainer.className = 'sub-nav-container';
    navContainer.dataset.navId = navId;
    groups.forEach(group => {
        const button = document.createElement('button');
        button.className = 'sub-nav-button';
        button.textContent = group;
        button.dataset.targetGroup = group;
        button.classList.toggle('active', group === activeGroup);
        navContainer.appendChild(button);
    });
    return navContainer;
}

function createTableTitle(tag, title, description) {
    const wrapper = document.createElement(tag);
    const titleEl = document.createElement(tag === 'div' ? 'h4' : 'span');
    titleEl.textContent = title;
    wrapper.appendChild(titleEl);

    if (description) {
        const infoContainer = document.createElement('div');
        infoContainer.className = 'info-container';
        const infoIcon = document.createElement('span');
        infoIcon.className = 'info-icon';
        infoIcon.textContent = '?';
        const tooltip = document.createElement('div');
        tooltip.className = 'info-tooltip';
        tooltip.textContent = description;
        infoContainer.appendChild(infoIcon);
        infoContainer.appendChild(tooltip);
        wrapper.appendChild(infoContainer);
    }
    return wrapper;
}

function createStaticTable(archetypes, isEditable) {
    const tableContainer = document.createElement('div');
    tableContainer.className = 'table-container';
    const table = document.createElement('table');
    table.className = 'data-table';
    
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const firstTh = document.createElement('th');
    firstTh.innerHTML = `<div class="th-content">Archetype</div>`;
    headerRow.appendChild(firstTh);

    staticFields.forEach(f => {
        const th = document.createElement('th');
        const groupName = Object.keys(staticFieldGroups).find(group => staticFieldGroups[group].includes(f));
        th.dataset.group = groupName.replace(/\s/g, '-').replace('&', 'and');

        const contentDiv = document.createElement('div');
        contentDiv.className = 'th-content';
        contentDiv.textContent = staticFieldLabels[f];
        const infoContainer = createTableTitle('div', '', staticFieldDescriptions[f]).querySelector('.info-container');
        if(infoContainer) contentDiv.appendChild(infoContainer);
        th.appendChild(contentDiv);
        headerRow.appendChild(th);
    });

    const tbody = table.createTBody();
    archetypes.forEach(row => {
        const tr = tbody.insertRow();
        
        const archetypeCell = tr.insertCell();
        const labelWrapper = document.createElement('div');
        labelWrapper.className = 'archetype-label-wrapper';
        const labelSpan = document.createElement('span');
        labelSpan.textContent = row.archetype;
        labelWrapper.appendChild(labelSpan);
        const description = archetypeDescriptions[row.archetype] || archetypeDescriptions["Default"];
        const infoContainer = createTableTitle('div', '', description).querySelector('.info-container');
        if (infoContainer) {
            infoContainer.querySelector('.info-tooltip').classList.add('tooltip-right');
            labelWrapper.appendChild(infoContainer);
        }
        archetypeCell.appendChild(labelWrapper);

        staticFields.forEach(field => {
            const td = tr.insertCell();
            const groupName = Object.keys(staticFieldGroups).find(group => staticFieldGroups[group].includes(field));
            td.dataset.group = groupName.replace(/\s/g, '-').replace('&', 'and');
            
            const config = staticFieldSliderConfig[field];
            if (!config) return;

            const wrapper = document.createElement('div');
            wrapper.className = 'input-slider-wrapper';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'static-field-input';
            const value = row[field];
            input.value = (value !== null && typeof value !== 'undefined' && !isNaN(value)) ? config.format(value) : 'N/A';
            input.dataset.id = row.id;
            input.dataset.field = field;
            input.readOnly = !isEditable;
            wrapper.appendChild(input);

            if (isEditable) {
                const baselineRow = baselineData.find(br => br.id === row.id);
                if (baselineRow && Math.abs(parseFloat(value) - parseFloat(baselineRow[field])) > 1e-9) {
                    td.classList.add('changed');
                }
                const sliderContainer = document.createElement('div');
                sliderContainer.className = 'slider-container';
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = config.min; slider.max = config.max; slider.step = config.step;
                slider.value = value;
                sliderContainer.appendChild(slider);
                wrapper.appendChild(sliderContainer);
            }
            td.appendChild(wrapper);
        });
    });
    tableContainer.appendChild(table);
    return tableContainer;
}

function createProjectionGrid(archetypes, metric, isEditable) {
    const grid = document.createElement('div');
    grid.className = 'projection-grid';

    archetypes.forEach(row => {
        const archetypeRow = document.createElement('div');
        archetypeRow.className = 'projection-archetype-row';

        const archetypeLabel = document.createElement('div');
        archetypeLabel.className = 'projection-archetype-label';
        archetypeLabel.textContent = row.archetype;
        archetypeRow.appendChild(archetypeLabel);

        const yearGrid = document.createElement('div');
        yearGrid.className = 'year-inputs-grid';

        years.forEach((yearKey, index) => {
            const item = document.createElement('div');
            item.className = 'year-input-item';

            const label = document.createElement('label');
            label.textContent = `FY ${String(baseYearStart + index).slice(-2)}/${String(baseYearStart + index + 1).slice(-2)}`;
            
            const input = document.createElement('input');
            input.type = 'text';
            const value = row[metric]?.[yearKey];
            input.value = (value !== null && typeof value !== 'undefined' && !isNaN(value)) ? value.toFixed(2) : 'N/A';
            input.dataset.id = row.id;
            input.dataset.field = `${metric}.${yearKey}`;
            input.readOnly = !isEditable || yearKey === 'y0';

            const baselineRow = baselineData.find(br => br.id === row.id);
            if (isEditable && baselineRow && baselineRow[metric]?.[yearKey] !== value) {
                input.classList.add('changed');
            }

            item.appendChild(label);
            item.appendChild(input);
            yearGrid.appendChild(item);
        });
        archetypeRow.appendChild(yearGrid);
        grid.appendChild(archetypeRow);
    });
    return grid;
}

// --- Event Handling Logic ---
function handleDataInput(e) {
    const slider = e.target;
    if (slider.type !== 'range') return;
    
    const textInput = slider.closest('.input-slider-wrapper').querySelector('input[type=text]');
    const { id: rowId, field: fieldKey } = textInput.dataset;
    const config = staticFieldSliderConfig[fieldKey];
    const rowToUpdate = scenarioData.find(row => row.id === rowId);

    if (!rowToUpdate || !config) return;

    const newValue = parseFloat(slider.value);
    textInput.value = config.format(newValue);
    rowToUpdate[fieldKey] = newValue;
    updateChangeState(rowId, fieldKey);
}

function handleDataChange(e) {
    const textInput = e.target;
    if (textInput.type !== 'text' || !textInput.dataset.id) return;

    const { id: rowId, field: fieldKey } = textInput.dataset;
    const rowToUpdate = scenarioData.find(row => row.id === rowId);
    if (!rowToUpdate) return;
    
    if (staticFields.includes(fieldKey)) {
        const config = staticFieldSliderConfig[fieldKey];
        if (!config) return;
        let parsedValue = config.parse(textInput.value);
        const originalValue = rowToUpdate[fieldKey];
        if (isNaN(parsedValue)) {
            return textInput.value = (originalValue !== null && !isNaN(originalValue)) ? config.format(originalValue) : 'N/A';
        }
        const clampedValue = Math.max(config.min, Math.min(config.max, parsedValue));
        rowToUpdate[fieldKey] = clampedValue;
        textInput.value = config.format(clampedValue);
        const slider = textInput.closest('.input-slider-wrapper').querySelector('input[type=range]');
        if (slider) slider.value = clampedValue;
    } 
    else {
        const [metric, yearKey] = fieldKey.split('.');
        const numericValue = parseFloat(textInput.value);
        const originalValue = rowToUpdate[metric]?.[yearKey];
        if (isNaN(numericValue)) {
            textInput.value = (originalValue !== null && !isNaN(originalValue)) ? originalValue.toFixed(2) : 'N/A';
        } else {
            rowToUpdate[metric][yearKey] = numericValue;
            textInput.value = numericValue.toFixed(2);
        }
    }
    updateChangeState(rowId, fieldKey);
}

function updateChangeState(rowId, fieldKey) {
    const rowToUpdate = scenarioData.find(row => row.id === rowId);
    const baselineRow = baselineData.find(row => row.id === rowId);
    const inputElement = document.querySelector(`input[data-id="${rowId}"][data-field="${fieldKey}"]`);
    if (!inputElement || !baselineRow) return;
    
    const cell = inputElement.closest('td, .year-input-item');

    let isChanged = false;
    if (staticFields.includes(fieldKey)) {
        isChanged = Math.abs(parseFloat(rowToUpdate[fieldKey]) - parseFloat(baselineRow[fieldKey])) > 1e-9;
    } else {
        const [metric, yearKey] = fieldKey.split('.');
        isChanged = rowToUpdate[metric]?.[yearKey] !== baselineRow[metric]?.[yearKey];
    }
    
    if (cell.matches('td')) {
        cell.classList.toggle('changed', isChanged);
    } else {
        inputElement.classList.toggle('changed', isChanged);
    }

    const modality = rowToUpdate.modality;
    const tabButton = document.querySelector(`.tab-button[data-target="tab-${modality.toLowerCase().replace(/\s/g, '-')}"]`);
    if (tabButton) {
        tabButton.classList.toggle('has-changes', scenarioData.filter(r => r.modality === modality).some(r => hasRowChanged(r.id)));
    }
}

function hasRowChanged(rowId) {
    const scenarioRow = scenarioData.find(r => r.id === rowId);
    const baselineRow = baselineData.find(r => r.id === rowId);
    if (!scenarioRow || !baselineRow) return false;
    return staticFields.some(key => Math.abs(parseFloat(scenarioRow[key]) - parseFloat(baselineRow[key])) > 1e-9) || 
           projectionMetrics.some(metric => years.some(yearKey => scenarioRow[metric]?.[yearKey] !== baselineRow[metric]?.[yearKey]));
}

function exportScenarioCSV() {
    const spinner = document.getElementById('export-spinner');
    spinner.classList.remove('hidden');
    exportButton.disabled = true;

    setTimeout(() => { 
        const flatData = scenarioData.map(row => {
            const newFlatRow = { ...row };
            projectionMetrics.forEach(metric => {
                if (newFlatRow[metric]) {
                    years.forEach(yearKey => {
                        newFlatRow[`${metric}_${yearKey}`] = newFlatRow[metric][yearKey];
                    });
                    delete newFlatRow[metric];
                }
            });
            return newFlatRow;
        });

        const csv = Papa.unparse(flatData);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        const filename = (scenarioName.trim().replace(/\s+/g, '_') || 'scenario_export') + `_${new Date().toISOString().slice(0,10)}.csv`;
        link.setAttribute("download", filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        spinner.classList.add('hidden');
        exportButton.disabled = false;
        showMessage("CSV exported successfully!", "success");
    }, 500);
}

function hideAllSliders() {
    document.querySelectorAll('.slider-container.visible').forEach(slider => slider.classList.remove('visible'));
}

function showLoadingMessage(message) {
    app.innerHTML = `<div class="app-loading-message">${message}</div>`;
}

function showMessage(message, type = 'info') {
    const statusMessage = document.getElementById('status-message');
    const p = document.createElement('p');
    p.className = type;
    p.textContent = message;
    statusMessage.innerHTML = '';
    statusMessage.appendChild(p);
    setTimeout(() => { statusMessage.innerHTML = ''; }, 3000);
}
</script>
</body>
</html>
