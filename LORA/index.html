<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scenario Configurator</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    h1 { margin-bottom: 10px; }
    input[type="file"] { margin-bottom: 20px; }
    details { margin-bottom: 10px; border: 1px solid #ccc; padding: 10px; }
    summary { font-weight: bold; cursor: pointer; }
    .archetype { margin-left: 20px; }
    .baseline-fields { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; }
    .field { flex: 1 1 200px; }
    .projection-table { border-collapse: collapse; margin-left: 20px; }
    .projection-table th, .projection-table td { border: 1px solid #ccc; padding: 4px 8px; text-align: right; }
    input[type="text"] { width: 80px; }
    .error { color: red; }
  </style>
</head>
<body>

<h1>Scenario Configurator</h1>
<input type="file" id="upload" accept=".csv" />
<div id="error" class="error"></div>
<div id="viewer"></div>

<script>
const baselineFields = [
  "Routine machine hours", "OOH machine hours", "RA's per list",
  "MIT shift length", "MIT weeks lost", "Session length",
  "Clinical requirement", "Radiologist weeks lost"
];

const yearFields = [];  // e.g., ["IP volume step y0", ..., "IP volume step y10"]
const yearGroups = {};  // { "IP volume step": { y0: colname, ... } }

function parseYearHeaders(headers) {
  yearFields.length = 0;
  Object.keys(yearGroups).forEach(k => delete yearGroups[k]);
  headers.forEach(h => {
    const match = h.match(/^(.*) y(\d{1,2})$/);
    if (match) {
      const metric = match[1].trim();
      const year = "y" + match[2];
      yearFields.push(h);
      if (!yearGroups[metric]) yearGroups[metric] = {};
      yearGroups[metric][year] = h;
    }
  });
}

function createInput(value) {
  const input = document.createElement("input");
  input.type = "text";
  input.value = value;
  return input;
}

function buildUI(data) {
  const container = document.getElementById("viewer");
  container.innerHTML = "";

  const byModality = {};
  for (let row of data) {
    const modality = row["Modality"];
    const archetype = row["Archetype"];
    if (!byModality[modality]) byModality[modality] = {};
    if (!byModality[modality][archetype]) byModality[modality][archetype] = [];
    byModality[modality][archetype].push(row);
  }

  for (let modality in byModality) {
    const modWrap = document.createElement("details");
    modWrap.open = true;
    modWrap.innerHTML = `<summary>${modality}</summary>`;

    for (let archetype in byModality[modality]) {
      const archetypeWrap = document.createElement("details");
      archetypeWrap.className = "archetype";
      archetypeWrap.innerHTML = `<summary>${archetype}</summary>`;
      const row = byModality[modality][archetype][0];

      // Baseline fields
      const baselineDiv = document.createElement("div");
      baselineDiv.className = "baseline-fields";
      for (let field of baselineFields) {
        const val = row[field] || "";
        const box = document.createElement("div");
        box.className = "field";
        box.innerHTML = `<label>${field}<br/></label>`;
        box.querySelector("label").appendChild(createInput(val));
        baselineDiv.appendChild(box);
      }
      archetypeWrap.appendChild(baselineDiv);

      // Projection matrix
      const table = document.createElement("table");
      table.className = "projection-table";

      const headerRow = document.createElement("tr");
      headerRow.innerHTML = "<th>Metric</th>" + Array.from({ length: 11 }, (_, i) => `<th>y${i}</th>`).join("");
      table.appendChild(headerRow);

      for (let metric in yearGroups) {
        const rowEl = document.createElement("tr");
        rowEl.innerHTML = `<td>${metric}</td>`;
        for (let i = 0; i <= 10; i++) {
          const colName = yearGroups[metric]["y" + i];
          const val = row[colName] || "";
          const cell = document.createElement("td");
          cell.appendChild(createInput(val));
          rowEl.appendChild(cell);
        }
        table.appendChild(rowEl);
      }

      archetypeWrap.appendChild(table);
      modWrap.appendChild(archetypeWrap);
    }
    container.appendChild(modWrap);
  }
}

document.getElementById("upload").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    complete: function(results) {
      const data = results.data;
      const headers = results.meta.fields;
      const requiredCols = ["Modality", "Archetype", ...baselineFields];
      const missing = requiredCols.filter(h => !headers.includes(h));
      if (missing.length) {
        document.getElementById("error").textContent = "Missing columns: " + missing.join(", ");
        return;
      }

      parseYearHeaders(headers);
      buildUI(data);
      document.getElementById("error").textContent = "";
    },
    error: function(err) {
      document.getElementById("error").textContent = "Parse error: " + err.message;
    }
  });
});
</script>

</body>
</html>