# Implementation Plan: Human-in-the-Loop (HITL) Validation Pipeline

This document outlines the tasks required to build a robust, scalable Human-in-the-Loop (HITL) validation system for the radiology exam standardization application.

## 1. Core Principles

The system will be built on the following principles:
- **Validation by Exception:** The human validator's default action is to do nothing. Mappings are considered "approved" unless explicitly flagged for failure or review.
- **Stateful & Iterative:** The validation status of each input is tracked persistently, allowing for multiple validation cycles.
- **Singleton Suspicion:** Mappings with only one corresponding input are automatically flagged for human review.
- **Decision Deferral:** Validators can skip a decision on an ambiguous item, allowing it to be re-evaluated in future runs with more data.
- **Targeted Reprocessing:** Validators can flag items for reprocessing with specific hints (e.g., "force secondary pipeline").

## 1.1. Input Data Sources

The validation pipeline is designed to work with the standardized JSON format generated by the **"Export Mappings"** tool from the main application. This format can be obtained through two pathways:

### Direct Pipeline Integration
- After running a demo or processing batch in the main application
- User clicks "Validate Results" → Automatically passes current results to validation pipeline
- Seamless handoff without file export/import needed

### File Upload Path  
- User runs processing in main application → "Export Mappings" → Downloads JSON file
- Later: User uploads the exported JSON file to validation pipeline
- Supports batch validation and team collaboration workflows

### Expected Input Format
The validation system expects the exported mappings JSON format containing an array of mapping objects:
```json
[
  {
    "exam_code": "CT001",
    "exam_name": "CT Head without contrast", 
    "clean_name": "CT of head without contrast",
    "snomed_fsn": "Computed tomography of head without contrast (procedure)",
    "snomed_id": "SCTID_123456",
    "confidence": 0.92,
    "data_source": "HNZ_HDP", 
    "components": {
      "anatomy": ["head"],
      "modality": ["CT"],
      "contrast": ["without contrast"]
    },
    "all_candidates": [...],
    "ambiguous": false
  }
]
```

---

## 2. Task Breakdown

### Task 1: Data Models & State Management

The foundation of the system is a set of JSON files to manage state. These should be created in a new `validation/` directory.

#### 1.1. Create `validation_state.json` - UPDATED

This file is the master record of the validation status for every mapping from the exported results.

- **Action:** Create a script `validation/initialize_state.py`.
- **Logic:**
    1.  Read the exported mappings JSON file from either:
        - Direct pipeline handoff (current results in memory)  
        - Uploaded file from "Export Mappings" tool
    2.  For each mapping item, generate a `unique_mapping_id` using a SHA256 hash of key fields: `exam_name` + `exam_code` + `data_source` + `clean_name`.
    3.  Create a JSON object where keys are the `unique_mapping_id`.
    4.  The value for each key should be an object with the following schema:
        ```json
        {
          "unique_mapping_id": "sha256_hash_of_mapping_fields",
          "original_mapping": {
            "exam_name": "...",
            "exam_code": "...", 
            "clean_name": "...",
            "snomed_fsn": "...",
            "confidence": 0.92,
            "data_source": "...",
            "components": {...},
            "ambiguous": false
          },
          "validation_status": "pending_review",
          "validator_decision": null,
          "validation_notes": null,
          "needs_attention_flags": [],
          "timestamp_created": "2024-01-15T10:30:00Z",
          "timestamp_reviewed": null
        }
        ```
    5.  The `validation_status` field can have one of the following values: `pending_review`, `approved`, `rejected`, `needs_correction`, `deferred`.
    6.  Auto-flag items for attention based on:
        - Low confidence (< 0.85)
        - Ambiguous mappings (ambiguous: true)
        - Singleton mappings (only one input maps to this clean_name)

#### 1.2. Define `approved_mappings_cache.json` - UPDATED

This file acts as a high-speed cache for permanently approved mappings from the validation process.

- **Schema:** A key-value JSON object mapping unique_mapping_id to approved mapping.
  ```json
  {
    "unique_mapping_id_1": {
      "exam_code": "CT001",
      "exam_name": "CT Head without contrast",
      "clean_name": "CT of head without contrast", 
      "snomed_id": "SCTID_123456",
      "snomed_fsn": "Computed tomography of head without contrast (procedure)",
      "confidence": 0.92,
      "components": { "anatomy": ["head"], "modality": ["CT"] },
      "approved_by": "validator_id",
      "approved_timestamp": "2024-01-15T14:30:00Z"
    }
  }```


#### 1.3. Define `rejected_mappings.json` - UPDATED
This file is a cache for mappings that have been rejected during validation.

**Schema:** A key-value JSON object.
```json
{
  "unique_mapping_id_1": {
    "original_mapping": {
      "exam_name": "...",
      "clean_name": "...",
      "confidence": 0.45
    },
    "rejection_reason": "Incorrect anatomy mapping - maps to wrong body part",
    "rejected_by": "validator_id", 
    "timestamp": "2024-01-15T10:00:00Z",
    "suggested_correction": "Should map to 'CT of chest' instead"
  }
}```

### Task 2: Frontend Integration & Validation API
Integrate validation functionality with the existing frontend and create validation-specific endpoints.

#### 2.1. Frontend: Validation Data Handoff - NEW
**Action:** Modify the main application's results section to support validation pipeline integration.
**Logic:**
1. **"Validate Results" Button:** Already implemented in results section
2. **Data Preparation:** When user clicks "Validate Results":
   - Take current `allMappings` array from processing results
   - Convert to validation format (same as Export Mappings format)  
   - Pass directly to validation UI without file export/import
3. **File Upload Support:** Allow users to upload previously exported mappings JSON files
4. **Format Consistency:** Ensure both pathways use identical JSON structure

#### 2.2. Backend: Validation API Endpoints - NEW  
**Action:** Create new validation-specific API endpoints in the backend.
**Logic:**
Create `/validation/` endpoints:
- `POST /validation/initialize` - Initialize validation state from mappings JSON
- `GET /validation/state` - Retrieve current validation state
- `POST /validation/decisions` - Submit validation decisions  
- `POST /validation/commit` - Commit approved mappings to production system
- `GET /validation/export` - Export validation decisions as JSON

#### 2.3. Backend: Validation Cache Integration - NEW
**Action:** Integrate approved/rejected mapping caches with the main processing pipeline.
**Logic:**
1. **Pre-processing Cache Check:** Before processing any exam:
   - Generate `unique_mapping_id` for the potential result
   - Check if exam + expected_mapping combination exists in approved cache
   - If found, return cached approved mapping immediately  
   - Check rejected cache and skip processing if mapping was previously rejected
2. **Post-validation Integration:** After validation decisions are committed:
   - Update approved_mappings_cache.json with newly approved mappings
   - Update rejected_mappings.json with rejected mappings
   - Improve future processing speed and consistency

### Task 3: Validation Processing Scripts
These scripts handle the validation workflow and can be integrated into the web interface or run standalone.

#### 3.1. Create validation/load_mappings.py - UPDATED
**Action:** Load exported mappings JSON and initialize validation state.
**Logic:**
1. Accept input from two sources:
   - Direct array of mappings from frontend (current results)
   - Uploaded JSON file from "Export Mappings" tool
2. For each mapping in the input:
   - Generate `unique_mapping_id` from exam_code + exam_name + data_source + clean_name
   - Create validation state entry with original mapping data
   - Apply automatic flagging rules:
     - Flag if confidence < 0.85
     - Flag if ambiguous == true  
     - Flag singletons (mappings that appear only once for a given clean_name)
3. Save initialized state to `validation/validation_state.json`
4. Generate summary report of mappings requiring attention

#### 3.2. Create validation/prepare_ui_data.py - UPDATED  
**Action:** Transform validation state into UI-friendly format for review.
**Logic:**
1. Load current `validation/validation_state.json`
2. Group mappings by clean_name for consolidated review
3. For each group:
   - Count total mappings per clean_name
   - Identify singletons (count == 1) and flag for attention
   - Calculate confidence statistics  
   - Highlight ambiguous or low-confidence mappings
4. Apply smart sorting:
   - Priority 1: Flagged items (low confidence, ambiguous, singletons)
   - Priority 2: High-confidence items needing approval
   - Priority 3: Already reviewed items
5. Export to `validation/ui_data.json` for frontend consumption

#### 3.3. Create validation/apply_decisions.py - UPDATED
**Action:** Process validation decisions and update system state.
**Logic:**
1. Accept validation decisions in JSON format:
```json
{
  "unique_mapping_id_1": { 
    "decision": "approve", 
    "notes": "Mapping is correct",
    "validator_id": "user123"
  },
  "unique_mapping_id_2": { 
    "decision": "reject", 
    "notes": "Wrong anatomy - should be chest not head",
    "suggested_correction": "CT of chest without contrast"
  },
  "unique_mapping_id_3": { 
    "decision": "defer", 
    "notes": "Need clinical expert review" 
  }
}```
2. Update validation_state.json with decisions and timestamps
3. Regenerate caches:
   - `approved_mappings_cache.json` - All approved mappings
   - `rejected_mappings.json` - All rejected mappings with reasons
4. Generate validation report showing decision summary and statistics

### Task 4: Build the Validation UI
This can be a simple, local, single-page static HTML file that uses JavaScript.

#### 4.1. Design validation_ui/index.html - DONE
Action: Describe the necessary HTML elements.
Required Components:
A file input element to allow the user to load the view_data.json.
A main container element (e.g., a div) where the validation view will be dynamically rendered.
A "Save Decisions" button element to trigger the download of the decision file.
A script tag to include the JavaScript file (app.js).

#### 4.2. Implement validation_ui/app.js - DONE
Action: Implement the client-side logic for rendering and interaction.
Logic:
loadData() function: Reads the view_data.json file selected by the user.
renderView(data) function:
Takes the parsed view_data.json as input.
Dynamically creates the HTML for the grouped view.
Uses the needs_attention flag to apply a CSS class (e.g., .highlight) to rows requiring review.
Creates the [Review ▼], [Fail], and [Defer] buttons/dropdowns for each row. Each button should store the unique_input_id in a data attribute.
Event Listeners:
Attach click listeners to all action buttons.
When a button is clicked, store the decision in a global JavaScript object, e.g., let userDecisions = {};.
The key should be the unique_input_id from the row's data attribute.
Visually update the row's "Status" to show it has been actioned (e.g., "Flagged for Fail").
saveDecisions() function:
Attached to the "Save Decisions" button.
Converts the userDecisions object to a JSON string.
Triggers a browser download of this JSON, naming the file decisions.json. This is the file that will be passed to update_state.py.

### Task 5: Updated End-to-End Workflow - UPDATED

The validation workflow now integrates seamlessly with the main application's Export Mappings functionality:

#### Integrated Web Workflow (Recommended)
1. **Run Processing:** Use the main application to run demo or batch processing
2. **Export/Validate Results:** Two options:
   - **Option A - Direct:** Click "Validate Results" button → Automatically loads current results into validation pipeline  
   - **Option B - File-based:** Click "Export Mappings" → Download JSON → Upload to validation pipeline later
3. **Review Mappings:** Use validation UI to review flagged items (low confidence, ambiguous, singletons)
4. **Make Decisions:** Approve, reject, or defer mappings with optional notes
5. **Commit Changes:** Submit validation decisions → Updates approved/rejected caches → Improves future processing

#### Standalone Script Workflow (For Advanced Users)  
1. Export mappings JSON from main application
2. `python validation/load_mappings.py exported_mappings.json` - Initialize validation state
3. `python validation/prepare_ui_data.py` - Generate UI-friendly data
4. Open validation UI → Load ui_data.json → Make validation decisions → Export decisions.json
5. `python validation/apply_decisions.py decisions.json` - Apply decisions and update caches

#### Key Benefits
- **Seamless Integration:** No file export/import needed for direct validation
- **Format Consistency:** Uses standard Export Mappings JSON format
- **Iterative Improvement:** Approved/rejected mappings improve future processing accuracy
- **Team Collaboration:** Export/import validation files for distributed review
- **Quality Assurance:** Automatic flagging of questionable mappings for human attention